{"projectName":"bacon.js","metric":"ADI","usabilityResult":{"index":0.5108080808080809},"modules":{"..\\src\\when.ts":{"moduleComponents":{"when":{"kind":13,"usabilityResult":{"wordCount":239,"index":1},"sources":{"name":"when","statements":["return <any>when_(newEventStream, patterns)"],"parameters":[{"name":"patterns","type":"Pattern<O>[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"EventStream<O>","typeParameters":[{"name":"O","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n The `when` method provides a generalization of the [`zip`](classes/observable.html#zip) function. While zip\r\n synchronizes events from multiple streams pairwse, the join patterns used in `when` allow\r\n the implementation of more advanced synchronization patterns.\r\n\r\n Consider implementing a game with discrete time ticks. We want to\r\n handle key-events synchronized on tick-events, with at most one key\r\n event handled per tick. If there are no key events, we want to just\r\n process a tick.\r\n\r\n ```js\r\n Bacon.when(\r\n [tick, keyEvent, function(_, k) { handleKeyEvent(k); return handleTick(); }],\r\n [tick, handleTick])\r\n ```\r\n\r\n Order is important here. If the [tick] patterns had been written\r\n first, this would have been tried first, and preferred at each tick.\r\n\r\n Join patterns are indeed a generalization of zip, and for EventStreams, zip is\r\n equivalent to a single-rule join pattern. The following observables\r\n have the same output, assuming that all sources are EventStreams.\r\n\r\n ```js\r\n Bacon.zipWith(a,b,c, combine)\r\n Bacon.when([a,b,c], combine)\r\n ```\r\n\r\n Note that [`Bacon.when`](#bacon-when) does not trigger updates for events from Properties though;\r\n if you use a Property in your pattern, its value will be just sampled when all the\r\n other sources (EventStreams) have a value. This is useful when you need a value of a Property\r\n in your calculations. If you want your pattern to fire for a Property too, you can\r\n convert it into an EventStream using [`property.changes()`](#property-changes) or [`property.toEventStream()`](#property-toeventstream)","tags":[{"kind":25,"tagName":"param","text":"{Pattern<O>} patterns Join patterns"},{"kind":25,"tagName":"typeparam","text":"O result type"}]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"when","modulePath":"..\\src\\when.ts"}}},"usabilityResult":{"index":1}},"..\\src\\combinetemplate.ts":{"moduleComponents":{"combineTemplate":{"kind":13,"usabilityResult":{"wordCount":0,"index":0},"sources":{"name":"combineTemplate","statements":[{"name":"current","statements":["return ctxStack[ctxStack.length - 1];"],"parameters":[{"name":"ctxStack","type":"Ctx[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"setValue","statements":["(<any>current(ctxStack))[key] = value;","return value;"],"parameters":[{"name":"ctxStack","type":"Ctx[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"key","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"value","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"applyStreamValue","statements":["return function(ctxStack: Ctx[], values: any[]) {\r\n  setValue(ctxStack, key, values[index]);\r\n};"],"parameters":[{"name":"key","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"index","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"constantValue","statements":["return function(ctxStack: Ctx[]) {\r\n  setValue(ctxStack, key, value);\r\n};"],"parameters":[{"name":"key","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"value","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"mkContext","statements":["return isArray(template) ? [] : {};"],"parameters":[{"name":"template","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"any","typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"pushContext","statements":["return function(ctxStack: Ctx[]) {\r\n  const newContext = mkContext(value);\r\n  setValue(ctxStack, key, newContext);\r\n  ctxStack.push(newContext);\r\n};"],"parameters":[{"name":"key","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"value","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"containsObservables","statements":["if (isObservable(value)) {\r\n  return true\r\n} else if (value && (value.constructor == Object || value.constructor == Array)) {\r\n  for (var key in value) {\r\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n      const child = value[key];\r\n      if (containsObservables(child))\r\n        return true\r\n    }\r\n  }\r\n}"],"parameters":[{"name":"value","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"compile","statements":["if (isObservable(value)) {\r\n  streams.push(value);\r\n  funcs.push(applyStreamValue(key, streams.length - 1));\r\n} else if (containsObservables(value)) {\r\n  const popContext = function(ctxStack: Ctx[]) { ctxStack.pop(); };\r\n  funcs.push(pushContext(key, value));\r\n  compileTemplate(value);\r\n  funcs.push(popContext);\r\n} else {\r\n  funcs.push(constantValue(key, value));\r\n}"],"parameters":[{"name":"key","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"value","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"combinator","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"const","declarations":[{"name":"rootContext","initializer":"mkContext(template)","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"const","declarations":[{"name":"ctxStack","initializer":"[rootContext]","hasExclamationToken":false,"kind":40}]},"for (var i = 0, f; i < funcs.length; i++) {\r\n  f = funcs[i];\r\n  f(ctxStack, values);\r\n}","return rootContext;"],"parameters":[{"name":"values","type":"any[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"name":"compileTemplate","statements":["_.each(template, compile);"],"parameters":[{"name":"template","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"const","declarations":[{"name":"funcs","initializer":"[]","type":"Function[]","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"const","declarations":[{"name":"streams","initializer":"[]","type":"Observable<any>[]","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"const","declarations":[{"name":"resultProperty","initializer":"containsObservables(template) \r\n    ? (compileTemplate(template), combineAsArray(streams).map(combinator))\r\n    : constant(template)","hasExclamationToken":false,"kind":40}]},"return <any>resultProperty.withDesc(new Desc(\"Bacon\", \"combineTemplate\", [template]));"],"parameters":[{"name":"template","type":"T","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<CombinedTemplate<T>>","typeParameters":[{"name":"T","kind":39,"isConst":false,"variance":0}],"docs":[],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"combineTemplate","modulePath":"..\\src\\combinetemplate.ts"}}},"usabilityResult":{"index":0}},"..\\src\\concat.ts":{"moduleComponents":{"concatAll":{"kind":13,"usabilityResult":{"wordCount":37,"index":0.74},"sources":{"name":"concatAll","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"streams","initializer":"argumentsToObservables(streams_)","hasExclamationToken":false,"kind":40}]},"return (streams.length\r\n? fold(tail(streams), head(streams).toEventStream(), (a: EventStream<V>, b: Observable<V>) => a.concat(b))\r\n: never<V>()\r\n).withDesc(new Desc(\"Bacon\", \"concatAll\", streams))"],"parameters":[{"name":"streams_","type":"(Observable<V> | Observable<V>[])[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Concatenates given array of EventStreams or Properties. Works by subscribing to the first source, and listeing to that\r\n until it ends. Then repeatedly subscribes to the next source, until all sources have ended.\r\n\r\n See [`concat`](#observable-concat)","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"concatAll","modulePath":"..\\src\\concat.ts"}}},"usabilityResult":{"index":0.74}},"..\\src\\constant.ts":{"moduleComponents":{"constant":{"kind":13,"usabilityResult":{"wordCount":7,"index":0.14},"sources":{"name":"constant","statements":["return new Property<V>(new Desc(\"Bacon\", \"constant\", [x]), function(sink : EventSink<V>) {\r\nsink(initialEvent(x));\r\nsink(endEvent());\r\nreturn nop;\r\n});"],"parameters":[{"name":"x","type":"V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Creates a constant property with value `x`.","tags":[]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"constant","modulePath":"..\\src\\constant.ts"}}},"usabilityResult":{"index":0.14}},"..\\src\\fromarray.ts":{"moduleComponents":{"fromArray":{"kind":13,"usabilityResult":{"wordCount":53,"index":1},"sources":{"name":"fromArray","statements":["assertArray(values);","if (!values.length) {\r\n    return never<T>().withDesc(new Desc(\"Bacon\", \"fromArray\", values));\r\n  } else {\r\n    var i = 0;\r\n    var stream = new EventStream(new Desc(\"Bacon\", \"fromArray\", [values]), function(sink: EventSink<T>) {\r\n      var unsubd = false;\r\n      var reply = more;\r\n      var pushing = false;\r\n      var pushNeeded = false;\r\n      function push() {\r\n        pushNeeded = true;\r\n        if (pushing) {\r\n          return;\r\n        }\r\n        if (i === values.length) {\r\n          sink(endEvent());\r\n          return false;\r\n        }\r\n        pushing = true;\r\n        while (pushNeeded) {\r\n          pushNeeded = false;\r\n          if ((reply !== noMore) && !unsubd) {\r\n            var value = values[i++];\r\n            reply = sink(toEvent(value));\r\n            if (reply !== noMore) {\r\n              if (i === values.length) {\r\n                sink(endEvent());\r\n              } else {\r\n                UpdateBarrier.afterTransaction(stream, push);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        pushing = false;\r\n        return pushing;\r\n      }\r\n\r\n      UpdateBarrier.soonButNotYet(stream, push)\r\n\r\n      return function() {\r\n        unsubd = true;\r\n        return unsubd;\r\n      };\r\n    });\r\n    return stream;\r\n  }"],"parameters":[{"name":"values","type":"(T | Event<T>)[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<T>","typeParameters":[{"name":"T","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Creates an EventStream that delivers the given\r\n series of values (given as array) to the first subscriber. The stream ends after these\r\n values have been delivered. You can also send [`Bacon.Error`](classes/error.html) events, or\r\n any combination of pure values and error events like this:\r\n `Bacon.fromArray([1, new Bacon.Error()])","tags":[{"kind":25,"tagName":"param","text":"  values    Array of values or events to repeat"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromArray","modulePath":"..\\src\\fromarray.ts"}}},"usabilityResult":{"index":1}},"..\\src\\frombinder.ts":{"moduleComponents":{"fromBinder":{"kind":13,"usabilityResult":{"wordCount":346,"index":1},"sources":{"name":"fromBinder","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"desc","initializer":"new Desc(\"Bacon\", \"fromBinder\", [binder, eventTransformer])","hasExclamationToken":false,"kind":40}]},"return new EventStream(desc, function(sink: EventSink<V>) {\r\nvar unbound = false;\r\nvar shouldUnbind = false;\r\nvar unbind = function() {\r\n  if (!unbound) {\r\n    if ((typeof unbinder !== \"undefined\" && unbinder !== null)) {\r\n      unbinder();\r\n      return unbound = true;\r\n    } else {\r\n      return shouldUnbind = true;\r\n    }\r\n  }\r\n};\r\nvar unbinder = binder(function(...args: any[]) {\r\n  var value_: EventLike<V> = eventTransformer(...args);\r\n  let valueArray: (V | Event<V>)[] = isArray(value_) && isEvent(_.last(value_ as any[]))\r\n    ? value_ as Event<V>[]\r\n    : [value_ as V|Event<V>]\r\n  var reply = more;\r\n  for (var i = 0; i < valueArray.length; i++) {\r\n    let event = toEvent(valueArray[i])\r\n    reply = sink(event)\r\n    if (reply === noMore || event.isEnd) {\r\n      // defer if binder calls handler in sync before returning unbinder\r\n      unbind()\r\n      return reply\r\n    }\r\n  }\r\n  return reply\r\n})\r\nif (shouldUnbind) {\r\n  unbind()\r\n}\r\nreturn unbind;\r\n})"],"parameters":[{"name":"binder","type":"Binder<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"eventTransformer","initializer":"_.id","type":"EventTransformer<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n If none of the other factory methods above apply, you may of course roll your own EventStream by using `fromBinder`.\r\n\r\n <a name=\"bacon-frombinder\"></a>\r\n [`Bacon.fromBinder(subscribe)`](#bacon-frombinder \"Bacon.fromBinder(subscribe)\") The parameter `subscribe` is a function that accepts a `sink` which is a function that your `subscribe` function can \"push\" events to.\r\n\r\n For example:\r\n\r\n ```js\r\n var stream = Bacon.fromBinder(function(sink) {\r\n  sink(\"first value\")\r\n  sink([new Bacon.Next(\"2nd\"), new Bacon.Next(\"3rd\")])\r\n  sink(new Bacon.Error(\"oops, an error\"))\r\n  sink(new Bacon.End())\r\n  return function() {\r\n     // unsub functionality here, this one's a no-op\r\n  }\r\n})\r\n stream.log()\r\n ```\r\n\r\n As shown in the example, you can push\r\n\r\n - A plain value, like `\"first value\"`\r\n - An [`Event`](#event) object including [`Bacon.Error`](#bacon-error) (wraps an error) and [`Bacon.End`](#bacon-end) (indicates\r\n stream end).\r\n - An array of [event](#event) objects at once\r\n\r\n Other examples can be found on [JSFiddle](http://jsfiddle.net/PG4c4/) and the\r\n [Bacon.js blog](http://baconjs.blogspot.fi/2013/12/wrapping-things-in-bacon.html).\r\n\r\n The `subscribe` function must return a function. Let's call that function\r\n `unsubscribe`. The returned function can be used by the subscriber (directly or indirectly) to\r\n unsubscribe from the EventStream. It should release all resources that the subscribe function reserved.\r\n\r\n The `sink` function may return [`Bacon.noMore`](#bacon-nomore) (as well as [`Bacon.more`](#bacon-more)\r\n or any other value). If it returns [`Bacon.noMore`](#bacon-nomore), no further events will be consumed\r\n by the subscriber. The `subscribe` function may choose to clean up all resources at this point (e.g.,\r\n by calling `unsubscribe`). This is usually not necessary, because further calls to `sink` are ignored,\r\n but doing so can increase performance in [rare cases](https://github.com/baconjs/bacon.js/issues/484).\r\n\r\n The EventStream will wrap your `subscribe` function so that it will\r\n only be called when the first stream listener is added, and the `unsubscribe`\r\n function is called only after the last listener has been removed.\r\n The subscribe-unsubscribe cycle may of course be repeated indefinitely,\r\n so prepare for multiple calls to the subscribe function.","tags":[{"kind":25,"tagName":"param","text":" binder"},{"kind":25,"tagName":"param","text":" eventTransformer"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromBinder","modulePath":"..\\src\\frombinder.ts"}}},"usabilityResult":{"index":1}},"..\\src\\fromevent.ts":{"moduleComponents":{"fromEvent":{"kind":13,"usabilityResult":{"wordCount":73,"index":1},"sources":{"name":"fromEvent","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"[sub, unsub]","initializer":"findHandlerMethods(target)","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"desc","initializer":"new Desc(\"Bacon\", \"fromEvent\", [target, eventSource])","hasExclamationToken":false,"kind":40}]},"return fromBinder<V>(function (handler) {\r\nif (isEventSourceFn(eventSource)) {\r\n  eventSource(sub.bind(target), handler);\r\n  return function () {\r\n    return eventSource(unsub.bind(target), handler);\r\n  }\r\n} else {\r\n  sub.call(target, eventSource, handler);\r\n  return function () {\r\n    return unsub.call(target, eventSource, handler);\r\n  };\r\n}\r\n}, eventTransformer).withDesc(desc);"],"parameters":[{"name":"target","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"eventSource","type":"string | EventSourceFn","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"eventTransformer","type":"EventTransformer<V>","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n creates an EventStream from events\r\n on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.\r\n You can also pass an optional function that transforms the emitted\r\n events' parameters.\r\n\r\n The simple form:\r\n\r\n ```js\r\n Bacon.fromEvent(document.body, \"click\").onValue(function() { alert(\"Bacon!\") })\r\n ```\r\n\r\n Using a binder function:\r\n\r\n ```js\r\n Bacon.fromEvent(\r\n window,\r\n function(binder, listener) {\r\n    binder(\"scroll\", listener, {passive: true})\r\n  }\r\n ).onValue(function() {\r\n  console.log(window.scrollY)\r\n})\r\n ```","tags":[{"kind":25,"tagName":"param","text":"target"},{"kind":25,"tagName":"param","text":"eventSource"},{"kind":25,"tagName":"param","text":"eventTransformer"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromEvent","modulePath":"..\\src\\fromevent.ts"}},"fromEventTarget":{"kind":13,"usabilityResult":{"wordCount":73,"index":1},"sources":{"name":"fromEvent","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"[sub, unsub]","initializer":"findHandlerMethods(target)","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"desc","initializer":"new Desc(\"Bacon\", \"fromEvent\", [target, eventSource])","hasExclamationToken":false,"kind":40}]},"return fromBinder<V>(function (handler) {\r\nif (isEventSourceFn(eventSource)) {\r\n  eventSource(sub.bind(target), handler);\r\n  return function () {\r\n    return eventSource(unsub.bind(target), handler);\r\n  }\r\n} else {\r\n  sub.call(target, eventSource, handler);\r\n  return function () {\r\n    return unsub.call(target, eventSource, handler);\r\n  };\r\n}\r\n}, eventTransformer).withDesc(desc);"],"parameters":[{"name":"target","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"eventSource","type":"string | EventSourceFn","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"eventTransformer","type":"EventTransformer<V>","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n creates an EventStream from events\r\n on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.\r\n You can also pass an optional function that transforms the emitted\r\n events' parameters.\r\n\r\n The simple form:\r\n\r\n ```js\r\n Bacon.fromEvent(document.body, \"click\").onValue(function() { alert(\"Bacon!\") })\r\n ```\r\n\r\n Using a binder function:\r\n\r\n ```js\r\n Bacon.fromEvent(\r\n window,\r\n function(binder, listener) {\r\n    binder(\"scroll\", listener, {passive: true})\r\n  }\r\n ).onValue(function() {\r\n  console.log(window.scrollY)\r\n})\r\n ```","tags":[{"kind":25,"tagName":"param","text":"target"},{"kind":25,"tagName":"param","text":"eventSource"},{"kind":25,"tagName":"param","text":"eventTransformer"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromEventTarget","modulePath":"..\\src\\fromevent.ts"}}},"usabilityResult":{"index":1}},"..\\src\\frompoll.ts":{"moduleComponents":{"fromPoll":{"kind":13,"usabilityResult":{"wordCount":43,"index":0.86},"sources":{"name":"fromPoll","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"desc","initializer":"new Desc(\"Bacon\", \"fromPoll\", [delay, poll])","hasExclamationToken":false,"kind":40}]},"return fromBinder((function (handler) {\r\nvar id = GlobalScheduler.scheduler.setInterval(handler, delay);\r\nreturn function () {\r\n  return GlobalScheduler.scheduler.clearInterval(id);\r\n};\r\n}), poll).withDesc(desc);"],"parameters":[{"name":"delay","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"poll","type":"PollFunction<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Polls given function with given interval.\r\n Function should return Events: either [`Bacon.Next`](classes/next.html) or [`Bacon.End`](classes/end.html). Polling occurs only\r\n when there are subscribers to the stream. Polling ends permanently when\r\n `f` returns [`Bacon.End`](classes/end.html).","tags":[{"kind":25,"tagName":"param","text":"delay poll interval in milliseconds"},{"kind":25,"tagName":"param","text":"poll function to be polled"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromPoll","modulePath":"..\\src\\frompoll.ts"}}},"usabilityResult":{"index":0.86}},"..\\src\\groupsimultaneous.ts":{"moduleComponents":{"groupSimultaneous":{"kind":13,"usabilityResult":{"wordCount":0,"index":0},"sources":{"name":"groupSimultaneous","statements":["return groupSimultaneous_(argumentsToObservables(streams))"],"parameters":[{"name":"streams","type":"(Observable<V> | Observable<V>[])[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"EventStream<V[][]>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"groupSimultaneous","modulePath":"..\\src\\groupsimultaneous.ts"}}},"usabilityResult":{"index":0}},"..\\src\\interval.ts":{"moduleComponents":{"interval":{"kind":13,"usabilityResult":{"wordCount":11,"index":0.22},"sources":{"name":"interval","statements":["return fromPoll<V>(delay, function () {\r\nreturn nextEvent(value);\r\n}).withDesc(new Desc(\"Bacon\", \"interval\", [delay, value]));"],"parameters":[{"name":"delay","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"value","type":"V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Repeats the single element indefinitely with the given interval (in milliseconds)","tags":[{"kind":25,"tagName":"param","text":"  delay   Repeat delay in milliseconds"},{"kind":25,"tagName":"param","text":"  value   The single value to repeat"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"interval","modulePath":"..\\src\\interval.ts"}}},"usabilityResult":{"index":0.22}},"..\\src\\later.ts":{"moduleComponents":{"later":{"kind":13,"usabilityResult":{"wordCount":14,"index":0.28},"sources":{"name":"later","statements":["return fromBinder(function (sink: FlexibleSink<V>) {\r\nvar sender = function () {\r\n  return sink([toEvent(value), endEvent()])\r\n}\r\nvar id = GlobalScheduler.scheduler.setTimeout(sender, delay)\r\nreturn function () {\r\n  return GlobalScheduler.scheduler.clearTimeout(id)\r\n}\r\n}).withDesc(new Desc(\"Bacon\", \"later\", [delay, value]))"],"parameters":[{"name":"delay","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"value","type":"V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n\r\n Creates a single-element stream that emits given value after given delay and ends.","tags":[{"kind":25,"tagName":"param","text":"delay delay in milliseconds"},{"kind":25,"tagName":"param","text":"value value to be emitted"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"later","modulePath":"..\\src\\later.ts"}}},"usabilityResult":{"index":0.28}},"..\\src\\never.ts":{"moduleComponents":{"never":{"kind":13,"usabilityResult":{"wordCount":6,"index":0.12},"sources":{"name":"never","statements":["return new EventStream<V>(describe(\"Bacon\", \"never\"), (sink) => {\r\nsink(endEvent());\r\nreturn nop;\r\n});"],"parameters":[],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Creates an EventStream that immediately ends.","tags":[{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"never","modulePath":"..\\src\\never.ts"}}},"usabilityResult":{"index":0.12}},"..\\src\\onvalues.ts":{"moduleComponents":{"onValues":{"kind":13,"usabilityResult":{"wordCount":47,"index":0.94},"sources":{"name":"onValues","statements":["return combineAsArray(\r\nargs.slice(0, args.length - 1)\r\n).onValues(args[arguments.length - 1])"],"parameters":[{"name":"args","type":"any[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"\r\n A shorthand for combining multiple\r\n sources (streams, properties, constants) as array and assigning the\r\n side-effect function f for the values. The following example would log\r\n the number 3.\r\n\r\n ```js\r\n function f(a, b) { console.log(a + b) }\r\n Bacon.onValues(Bacon.constant(1), Bacon.constant(2), f)\r\n ```","tags":[]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"onValues","modulePath":"..\\src\\onvalues.ts"}}},"usabilityResult":{"index":0.94}},"..\\src\\once.ts":{"moduleComponents":{"once":{"kind":13,"usabilityResult":{"wordCount":41,"index":0.82},"sources":{"name":"once","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"const","declarations":[{"name":"s","initializer":"new EventStream<V>(new Desc(\"Bacon\", \"once\", [value]), function(sink: EventSink<V>) {\r\n    UpdateBarrier.soonButNotYet(s, function() {\r\n      sink(toEvent(value));\r\n      sink(endEvent());  \r\n    })\r\n    return nop\r\n  })","hasExclamationToken":false,"kind":40}]},"return s"],"parameters":[{"name":"value","type":"V | Event<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Creates an EventStream that delivers the given\r\n single value for the first subscriber. The stream will end immediately\r\n after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a\r\n value: `Bacon.once(new Bacon.Error(\"fail\"))`.","tags":[{"kind":25,"tagName":"param","text":"  value   the value or event to emit"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"once","modulePath":"..\\src\\once.ts"}}},"usabilityResult":{"index":0.82}},"..\\src\\repeat.ts":{"moduleComponents":{"repeat":{"kind":13,"usabilityResult":{"wordCount":93,"index":1},"sources":{"name":"repeat","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"index","initializer":"0","hasExclamationToken":false,"kind":40}]},"return fromBinder<V>(function(sink: EventSink<V>) {\r\nvar flag = false;\r\nvar reply = more;\r\nvar unsub = function() {};\r\nfunction handleEvent(event: Event<V>): Reply {\r\n  if (event.isEnd) {\r\n    if (!flag) {\r\n      flag = true;\r\n    } else {\r\n      subscribeNext();\r\n    }\r\n    return more\r\n  } else {\r\n    return reply = sink(event);\r\n  }\r\n}\r\nfunction subscribeNext() {\r\n  var next: Observable<V> | undefined;\r\n  flag = true;\r\n  while (flag && reply !== noMore) {\r\n    next = generator(index++);\r\n    flag = false;\r\n    if (next) {\r\n      unsub = next.subscribeInternal(handleEvent);\r\n    } else {\r\n      sink(endEvent());\r\n    }\r\n  }\r\n  flag = true;\r\n}\r\nsubscribeNext();\r\nreturn () => unsub();\r\n}).withDesc(new Desc(\"Bacon\", \"repeat\", [generator]))"],"parameters":[{"name":"generator","type":"(iteration: number) => (Observable<V> | undefined)","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Calls generator function which is expected to return an observable. The returned EventStream contains\r\n values and errors from the spawned observable. When the spawned observable ends, the generator is called\r\n again to spawn a new observable.\r\n\r\n This is repeated until the generator returns a falsy value\r\n (such as `undefined` or `false`).\r\n\r\n The generator function is called with one argument — iteration number starting from `0`.\r\n\r\n Here's an example:\r\n\r\n```js\r\nBacon.repeat(function(i) {\r\nif (i < 3) {\r\n  return Bacon.once(i);\r\n} else {\r\n  return false;\r\n}\r\n}).log()\r\n```\r\n\r\n The example will produce values 0, 1 and 2.","tags":[{"kind":25,"tagName":"param","text":"{(number) => (Observable<V> | null)} generator"},{"kind":25,"tagName":"returns","text":"{EventStream<V>}"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"repeat","modulePath":"..\\src\\repeat.ts"}}},"usabilityResult":{"index":1}},"..\\src\\repeatedly.ts":{"moduleComponents":{"repeatedly":{"kind":13,"usabilityResult":{"wordCount":29,"index":0.58},"sources":{"name":"repeatedly","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"index","initializer":"0","hasExclamationToken":false,"kind":40}]},"return fromPoll(delay, function () {\r\nreturn values[index++ % values.length];\r\n}).withDesc(new Desc(\"Bacon\", \"repeatedly\", [delay, values]));"],"parameters":[{"name":"delay","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"values","type":"(V | Event<V>)[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Repeats given elements indefinitely\r\n with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`\r\n would lead to `1,2,3,1,2,3...` to be repeated indefinitely.","tags":[{"kind":25,"tagName":"param","text":"delay between values, in milliseconds"},{"kind":25,"tagName":"param","text":"values array of values to repeat"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"repeatedly","modulePath":"..\\src\\repeatedly.ts"}}},"usabilityResult":{"index":0.58}},"..\\src\\retry.ts":{"moduleComponents":{"retry":{"kind":13,"usabilityResult":{"wordCount":68,"index":1},"sources":{"name":"retry","statements":["if (!_.isFunction(options.source)) {\r\nthrow new Exception(\"'source' option has to be a function\");\r\n}",{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"source","initializer":"options.source","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"retries","initializer":"options.retries || 0","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"retriesDone","initializer":"0","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"delay","initializer":"options.delay || function() {\r\n    return 0;\r\n  }","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"isRetryable","initializer":"options.isRetryable || function() {\r\n    return true;\r\n  }","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"finished","initializer":"false","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"errorEvent","initializer":"null","type":"Error | null","hasExclamationToken":false,"kind":40}]},"return repeat<V>(function(count: number) {\r\n    function valueStream(): Observable<V> {\r\n      return source(count).endOnError().transform(function (event: Event<V>, sink: EventSink<V>): Reply {\r\n        if (isError(event)) {\r\n          errorEvent = event;\r\n          if (!(isRetryable(errorEvent.error) && (retries === 0 || retriesDone < retries))) {\r\n            finished = true;\r\n            return sink(event);\r\n          } else {\r\n            return more;\r\n          }\r\n        } else {\r\n          if (hasValue(event)) {\r\n            errorEvent = null;\r\n            finished = true;\r\n          }\r\n          return sink(event);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (finished) {\r\n      return undefined;\r\n    } else if (errorEvent) {\r\n      var context = {\r\n        error: errorEvent.error,\r\n        retriesDone\r\n      };\r\n      var pause: EventStream<V> = silence(delay(context));\r\n      retriesDone++\r\n      return pause.concat(once(<any>null).flatMap(valueStream));\r\n    } else {\r\n      return valueStream();\r\n    }\r\n  }).withDesc(new Desc(\"Bacon\", \"retry\", [options]));"],"parameters":[{"name":"options","type":"RetryOptions<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Used to retry the call when there is an [`Error`](classes/error.html) event in the stream produced by the `source` function.\r\n\r\n ```js\r\n var triggeringStream, ajaxCall // <- ajaxCall gives Errors on network or server errors\r\n ajaxResult = triggeringStream.flatMap(function(url) {\r\n    return Bacon.retry({\r\n        source: function(attemptNumber) { return ajaxCall(url) },\r\n        retries: 5,\r\n        isRetryable: function (error) { return error.httpStatusCode !== 404; },\r\n        delay: function(context) { return 100; } // Just use the same delay always\r\n    })\r\n})\r\n ```","tags":[{"kind":25,"tagName":"param","text":"options (click for details)"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"retry","modulePath":"..\\src\\retry.ts"}}},"usabilityResult":{"index":1}},"..\\src\\sequentially.ts":{"moduleComponents":{"sequentially":{"kind":13,"usabilityResult":{"wordCount":15,"index":0.3},"sources":{"name":"sequentially","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"index","initializer":"0","hasExclamationToken":false,"kind":40}]},"return fromPoll<V>(delay, function (): EventLike<V> {\r\nvar value = values[index++];\r\nif (index < values.length) {\r\n  return value;\r\n} else if (index === values.length) {\r\n  return [toEvent(value), endEvent()];\r\n} else {\r\n  return endEvent();\r\n}\r\n}).withDesc(new Desc(\"Bacon\", \"sequentially\", [delay, values]));"],"parameters":[{"name":"delay","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"values","type":"(V | Event<V>)[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Creates a stream containing given\r\n values (given as array). Delivered with given interval in milliseconds.","tags":[{"kind":25,"tagName":"param","text":"delay between elements, in milliseconds"},{"kind":25,"tagName":"param","text":"array of values or events"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"sequentially","modulePath":"..\\src\\sequentially.ts"}}},"usabilityResult":{"index":0.3}},"..\\src\\silence.ts":{"moduleComponents":{"silence":{"kind":13,"usabilityResult":{"wordCount":14,"index":0.28},"sources":{"name":"silence","statements":["return <any>later(duration, \"\")\r\n.filter(false)\r\n.withDesc(new Desc(\"Bacon\", \"silence\", [duration]));"],"parameters":[{"name":"duration","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Creates a stream that ends after given amount of milliseconds, without emitting any values.","tags":[{"kind":25,"tagName":"param","text":"duration duration of silence in milliseconds"},{"kind":25,"tagName":"typeparam","text":"V Type of stream elements"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"silence","modulePath":"..\\src\\silence.ts"}}},"usabilityResult":{"index":0.28}},"..\\src\\zip.ts":{"moduleComponents":{"zipAsArray":{"kind":13,"usabilityResult":{"wordCount":131,"index":1},"sources":{"name":"zipAsArray","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"streams","initializer":"_.map(((s: Observable<V>) => s.toEventStream()), argumentsToObservables(args))","hasExclamationToken":false,"kind":40}]},"return when([streams, (...xs: V[]) => xs]).withDesc(new Desc(\"Bacon\", \"zipAsArray\", args));"],"parameters":[{"name":"args","type":"(Observable<V> | Observable<V>[])[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"Observable<V[]>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Zips the array of EventStreams / Properties in to a new\r\n EventStream that will have an array of values from each source as\r\n its value. Zipping means that events from each source are combined\r\n pairwise so that the 1st event from each source is published first, then\r\n the 2nd event from each. The results will be published as soon as there\r\n is a value from each source.\r\n\r\n Be careful not to have too much \"drift\" between streams. If one stream\r\n produces many more values than some other excessive buffering will\r\n occur inside the zipped observable.\r\n\r\n Example:\r\n\r\n ```js\r\n x = Bacon.fromArray([1,2,3])\r\n y = Bacon.fromArray([10, 20, 30])\r\n z = Bacon.fromArray([100, 200, 300])\r\n Bacon.zipAsArray(x, y, z)\r\n\r\n # produces values [1, 10, 100], [2, 20, 200] and [3, 30, 300]\r\n ```","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"zipAsArray","modulePath":"..\\src\\zip.ts"}},"zipWith":{"kind":13,"usabilityResult":{"wordCount":26,"index":0.52},"sources":{"name":"zipWith","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"[streams, f]","initializer":"argumentsToObservablesAndFunction<Out>(arguments)","hasExclamationToken":false,"kind":40}]},"streams = _.map(((s: Observable<any>) => s.toEventStream()), streams);","return when([streams, f]).withDesc(new Desc(\"Bacon\", \"zipWith\", (<any[]>[f]).concat(streams)));"],"parameters":[{"name":"f","type":"(...any: any[]) => Out","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"streams","type":"Observable<any>[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"EventStream<Out>","typeParameters":[{"name":"Out","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Like [`zipAsArray`](#bacon-zipasarray) but uses the given n-ary\r\n function to combine the n values from n sources, instead of returning them in an Array.","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"zipWith","modulePath":"..\\src\\zip.ts"}}},"usabilityResult":{"index":0.76}},"..\\src\\merge.ts":{"moduleComponents":{"mergeAll":{"kind":13,"usabilityResult":{"wordCount":27,"index":0.54},"sources":{"name":"mergeAll","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"flattenedStreams","initializer":"argumentsToObservables(streams)","hasExclamationToken":false,"kind":40}]},"if (flattenedStreams.length) {\r\n    return new EventStream(new Desc(\"Bacon\", \"mergeAll\", flattenedStreams), function(sink) {\r\n      var ends = 0\r\n      var smartSink = function(obs: Observable<V>) {\r\n        return function(unsubBoth: Unsub) {\r\n          return obs.subscribeInternal(function(event: Event<V>) {\r\n            if (event.isEnd) {\r\n              ends++\r\n              if (ends === flattenedStreams.length) {\r\n                return sink(endEvent())\r\n              } else {\r\n                return more\r\n              }\r\n\r\n            } else {\r\n              event = event.toNext()\r\n              var reply = sink(event)\r\n              if (reply === noMore) { unsubBoth() }\r\n              return reply\r\n            }\r\n          })\r\n        }\r\n      }\r\n      var sinks = map(smartSink, flattenedStreams);\r\n      return new CompositeUnsubscribe(sinks).unsubscribe;\r\n    })\r\n  } else {\r\n    return never()\r\n  }"],"parameters":[{"name":"streams","type":"(Observable<V> | Observable<V>[])[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Merges given array of EventStreams or Properties, by collecting the values from all of the sources into a single\r\n EventStream.\r\n\r\n See also [`merge`](classes/eventstream.html#merge).","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"mergeAll","modulePath":"..\\src\\merge.ts"}}},"usabilityResult":{"index":0.54}},"..\\src\\frompromise.ts":{"moduleComponents":{"fromPromise":{"kind":13,"usabilityResult":{"wordCount":104,"index":1},"sources":{"name":"fromPromise","statements":["return fromBinder(function (handler) {\r\n    const bound = promise.then(handler, (e) => handler(new Error(e)));\r\n    if (bound && typeof (<any>bound).done === \"function\") {\r\n      (<any>bound).done();\r\n    }\r\n\r\n    if (abort) {\r\n      return function () {\r\n        if (typeof (<any>promise).abort === \"function\") {\r\n          return (<any>promise).abort();\r\n        }\r\n      };\r\n    } else {\r\n      return function () {\r\n      };\r\n    }\r\n  }, eventTransformer).withDesc(new Desc(\"Bacon\", \"fromPromise\", [promise]));"],"parameters":[{"name":"promise","type":"Promise<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"abort","type":"boolean","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"eventTransformer","initializer":"valueAndEnd","type":"EventTransformer<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nCreates an EventStream from a Promise object such as JQuery Ajax.\r\n This stream will contain a single value or an error, followed immediately by stream end.\r\n You can use the optional abort flag (i.e. ´fromPromise(p, true)´ to have the `abort` method of the given promise be called when all subscribers have been removed from the created stream.\r\n You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into `[new Bacon.Next(value), new Bacon.End()]`.\r\n Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).\r\n\r\n","tags":[{"kind":25,"tagName":"param","text":"{Promise<V>} source promise object"},{"kind":25,"tagName":"param","text":"abort should we call the `abort` method of the Promise on unsubscribe. This is a nonstandard feature you should probably ignore."},{"kind":25,"tagName":"param","text":"{EventTransformer<V>} eventTransformer"},{"kind":25,"tagName":"returns","text":"{EventStream<V>}"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromPromise","modulePath":"..\\src\\frompromise.ts"}}},"usabilityResult":{"index":1}},"..\\src\\callback.ts":{"moduleComponents":{"fromCallback":{"kind":13,"usabilityResult":{"wordCount":110,"index":1},"sources":{"name":"fromCallback","statements":["return fromBinder<V>(\r\nfunction(handler) {\r\n  makeFunction(f, args)(handler);\r\n  return nop;\r\n},\r\nfunction(value) {\r\n  return [value, endEvent()];\r\n}\r\n).withDesc(new Desc(\"Bacon\", \"fromCallback\", [f, ...args]))"],"parameters":[{"name":"f","type":"Function","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"args","type":"any[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Creates an EventStream from a function that\r\n accepts a callback. The function is supposed to call its callback just\r\n once. For example:\r\n\r\n ```js\r\n Bacon.fromCallback(callback => callback(\"bacon\"))\r\n ```\r\n\r\n This would create a stream that outputs a single value \"Bacon!\" and ends\r\n after that. The use of setTimeout causes the value to be delayed by 1\r\n second.\r\n\r\n You can also give any number of arguments to [`fromCallback`](#bacon-fromcallback), which will be\r\n passed to the function. These arguments can be simple variables, Bacon\r\n EventStreams or Properties. For example the following will output \"Bacon rules\":\r\n\r\n ```js\r\n bacon = Bacon.constant('bacon')\r\n Bacon.fromCallback(function(a, b, callback) {\r\n  callback(a + ' ' + b);\r\n}, bacon, 'rules').log();\r\n ```","tags":[{"kind":25,"tagName":"param","text":"f"},{"kind":25,"tagName":"param","text":"args"},{"kind":25,"tagName":"returns","text":"{EventStream<V>}"}]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromCallback","modulePath":"..\\src\\callback.ts"}},"fromNodeCallback":{"kind":13,"usabilityResult":{"wordCount":69,"index":1},"sources":{"name":"fromNodeCallback","statements":["return fromBinder<V>(\r\nfunction(handler) {\r\n  makeFunction(f, args)(handler);\r\n  return nop;\r\n},\r\nfunction(error, value) {\r\n  if (error) {\r\n    return [new Error(error), endEvent()]\r\n  }\r\n  return [value, endEvent()];\r\n}\r\n).withDesc(new Desc(\"Bacon\", \"fromNodeCallback\", [f, ...args]))"],"parameters":[{"name":"f","type":"Function","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"args","type":"any[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nBehaves the same way as `Bacon.fromCallback`,\r\nexcept that it expects the callback to be called in the Node.js convention:\r\n`callback(error, data)`, where error is null if everything is fine. For example:\r\n\r\n```js\r\nvar Bacon = require('baconjs').Bacon,\r\nfs = require('fs');\r\nvar read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');\r\nread.onError(function(error) { console.log(\"Reading failed: \" + error); });\r\nread.onValue(function(value) { console.log(\"Read contents: \" + value); });\r\n```","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromNodeCallback","modulePath":"..\\src\\callback.ts"}}},"usabilityResult":{"index":1}},"..\\src\\fromesobservable.ts":{"moduleComponents":{"fromESObservable":{"kind":13,"usabilityResult":{"wordCount":24,"index":0.48},"sources":{"name":"fromESObservable","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"observable","type":"any","hasExclamationToken":false,"kind":40}]},"if (_observable[symbol(\"observable\")]) {\r\nobservable = _observable[symbol(\"observable\")]();\r\n} else {\r\nobservable = _observable;\r\n}",{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"desc","initializer":"new Desc(\"Bacon\", \"fromESObservable\", [observable])","hasExclamationToken":false,"kind":40}]},"return new EventStream(desc, function(sink: EventSink<V>) {\r\n    var cancel = observable.subscribe({\r\n      error: function(x: any) {\r\n        sink(new Error(x));\r\n        sink(new End());\r\n      },\r\n      next: function(value: V) { sink(new Next(value)); },\r\n      complete: function() {\r\n        sink(new End());\r\n      }\r\n    });\r\n\r\n    // Support RxJS Observables\r\n    if (cancel.unsubscribe) {\r\n      return function() { cancel.unsubscribe(); };\r\n    } else {\r\n      return cancel;\r\n    }\r\n  });"],"parameters":[{"name":"_observable","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nCreates an EventStream from an\r\n [ES Observable](https://github.com/tc39/proposal-observable). Input can be any\r\n ES Observable implementation including RxJS and Kefir.","tags":[]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"fromESObservable","modulePath":"..\\src\\fromesobservable.ts"}}},"usabilityResult":{"index":0.48}},"..\\src\\observable.ts":{"moduleComponents":{"EventStream":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"bufferWithTime","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"bufferWithTime","statements":["return bufferWithTime(this, delay)"],"parameters":[{"name":"delay","type":"number | DelayFunction","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V[]>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Buffers stream events with given delay.\r\n   The buffer is flushed at most once in the given interval. So, if your input\r\n   contains [1,2,3,4,5,6,7], then you might get two events containing [1,2,3,4]\r\n   and [5,6,7] respectively, given that the flush occurs between numbers 4 and 5.\r\n\r\n   Also works with a given \"defer-function\" instead\r\n   of a delay. Here's a simple example, which is equivalent to\r\n   stream.bufferWithTime(10):\r\n\r\n   ```js\r\n   stream.bufferWithTime(function(f) { setTimeout(f, 10) })\r\n   ```","tags":[{"kind":25,"tagName":"param","text":"delay buffer duration in milliseconds"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"bufferWithCount","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"bufferWithCount","statements":["return bufferWithCount(this, count)"],"parameters":[{"name":"count","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V[]>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Buffers stream events with given count.\r\n   The buffer is flushed when it contains the given number of elements or the source stream ends.\r\n\r\n   So, if you buffer a stream of `[1, 2, 3, 4, 5]` with count `2`, you'll get output\r\n   events with values `[1, 2]`, `[3, 4]` and `[5]`.","tags":[{"kind":25,"tagName":"param","text":"{number} count"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"bufferWithTimeOrCount","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"bufferWithTimeOrCount","statements":["return bufferWithTimeOrCount(this, delay, count)"],"parameters":[{"name":"delay","type":"number | DelayFunction","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"count","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V[]>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Buffers stream events and\r\n   flushes when either the buffer contains the given number elements or the\r\n   given amount of milliseconds has passed since last buffered event.","tags":[{"kind":25,"tagName":"param","text":"{number | DelayFunction} delay in milliseconds or as a function"},{"kind":25,"tagName":"param","text":"{number} count  maximum buffer size"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"changes","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"changes","statements":["return this"],"parameters":[],"returnType":"EventStream<V>","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"concat","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"concat","statements":["return concatE(this, other, options)"],"parameters":[{"name":"other","type":"Observable<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"options","type":"EventStreamOptions","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<any>","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[{"parameters":[{"name":"other","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"options","type":"EventStreamOptions","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[],"hasOverrideKeyword":false,"docs":[{"kind":24,"description":"\r\n   Concatenates two streams/properties into one stream/property so that\r\n   it will deliver events from this observable until it ends and then deliver\r\n   events from `other`. This means too that events from `other`,\r\n   occurring before the end of this observable will not be included in the result\r\n   stream/property.","tags":[]}],"kind":27,"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}},{"parameters":[{"name":"other","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"options","type":"EventStreamOptions","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V | V2>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}]}},{"name":"transformChanges","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"transformChanges","statements":["return <any>f(this).withDesc(desc)"],"parameters":[{"name":"desc","type":"Desc","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"EventStreamDelay<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMap","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMap","statements":["return <any>flatMap(this, f)"],"parameters":[{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   For each element in the source stream, spawn a new\r\n   stream/property using the function `f`. Collect events from each of the spawned\r\n   streams into the result stream/property. Note that instead of a function, you can provide a\r\n   stream/property too. Also, the return value of function `f` can be either an\r\n   `Observable` (stream/property) or a constant value.\r\n\r\n   `stream.flatMap()` can be used conveniently with [`Bacon.once()`](../globals.html#once) and [`Bacon.never()`](../globals.html#never)\r\n   for converting and filtering at the same time, including only some of the results.\r\n\r\n   Example - converting strings to integers, skipping empty values:\r\n\r\n   ```js\r\n   stream.flatMap(function(text) {\r\n    return (text != \"\") ? parseInt(text) : Bacon.never()\r\n})\r\n   ```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapConcat","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapConcat","statements":["return <any>flatMapConcat(this, f)"],"parameters":[{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   A [`flatMapWithConcurrencyLimit`](#flatmapwithconcurrencylimit) with limit of 1.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapError","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapError","statements":["return <any>flatMapError(this, f)"],"parameters":[{"name":"f","type":"Function1<any, Observable<V2> | EventOrValue<V2>>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V | V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Like [`flatMap`](#flatmap), but is applied only on [`Error`](error.html) events. Returned values go into the\r\n   value stream, unless an error event is returned. As an example, one type of error could result in a retry and another just\r\n   passed through, which can be implemented using flatMapError.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapFirst","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapFirst","statements":["return <any>flatMapFirst(this, f)"],"parameters":[{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Like [`flatMap`](#observable-flatmap), but only spawns a new\r\n   stream if the previously spawned stream has ended.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapLatest","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapLatest","statements":["return <any>flatMapLatest(this, f)"],"parameters":[{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Like [`flatMap`](#flatmap), but instead of including events from\r\n   all spawned streams, only includes them from the latest spawned stream.\r\n   You can think this as switching from stream to stream.\r\n   Note that instead of a function, you can provide a stream/property too.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapWithConcurrencyLimit","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapWithConcurrencyLimit","statements":["return <any>flatMapWithConcurrencyLimit(this, limit, f)"],"parameters":[{"name":"limit","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   A super method of *flatMap* family. It limits the number of open spawned streams and buffers incoming events.\r\n   [`flatMapConcat`](#flatmapconcat) is `flatMapWithConcurrencyLimit(1)` (only one input active),\r\n   and [`flatMap`](#flatmap) is `flatMapWithConcurrencyLimit ∞` (all inputs are piped to output).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapEvent","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapEvent","statements":["return <any>flatMapEvent(this, f)"],"parameters":[{"name":"f","type":"EventSpawner<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"flatScan","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatScan","statements":["return <any>flatScan(this, seed, f)"],"parameters":[{"name":"seed","type":"V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Function2<V2, V, Observable<V2>>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Scans stream with given seed value and accumulator function, resulting to a Property.\r\n   Difference to [`scan`](#scan) is that the function `f` can return an [`EventStream`](eventstream.html) or a [`Property`](property.html) instead\r\n   of a pure value, meaning that you can use [`flatScan`](#flatscan) for asynchronous updates of state. It serializes\r\n   updates so that that the next update will be queued until the previous one has completed.","tags":[{"kind":25,"tagName":"param","text":"seed initial value to start with"},{"kind":25,"tagName":"param","text":"f transition function from previous state and new value to next state"},{"kind":25,"tagName":"typeparam","text":"V2 state and result type"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"groupBy","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"groupBy","statements":["return <any>groupBy(this, keyF, limitF)"],"parameters":[{"name":"keyF","type":"Function1<V, string>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"limitF","type":"GroupTransformer<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<EventStream<V2>>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"default":"V","variance":0}],"docs":[{"kind":24,"description":"\r\n   Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped\r\n   stream life. Stream transformed by `limitF` is passed on if provided. `limitF` gets grouped stream\r\n   and the original event causing the stream to start as parameters.\r\n\r\n   Calculator for grouped consecutive values until group is cancelled:\r\n\r\n   ```\r\n   var events = [\r\n   {id: 1, type: \"add\", val: 3 },\r\n   {id: 2, type: \"add\", val: -1 },\r\n   {id: 1, type: \"add\", val: 2 },\r\n   {id: 2, type: \"cancel\"},\r\n   {id: 3, type: \"add\", val: 2 },\r\n   {id: 3, type: \"cancel\"},\r\n   {id: 1, type: \"add\", val: 1 },\r\n   {id: 1, type: \"add\", val: 2 },\r\n   {id: 1, type: \"cancel\"}\r\n   ]\r\n\r\n   function keyF(event) {\r\n  return event.id\r\n}\r\n\r\n   function limitF(groupedStream, groupStartingEvent) {\r\n  var cancel = groupedStream.filter(function(x) { return x.type === \"cancel\"}).take(1)\r\n  var adds = groupedStream.filter(function(x) { return x.type === \"add\" })\r\n  return adds.takeUntil(cancel).map(\".val\")\r\n}\r\n\r\n   Bacon.sequentially(2, events)\r\n   .groupBy(keyF, limitF)\r\n   .flatMap(function(groupedStream) {\r\n    return groupedStream.fold(0, function(acc, x) { return acc + x })\r\n  })\r\n   .onValue(function(sum) {\r\n    console.log(sum)\r\n    // returns [-1, 2, 8] in an order\r\n  })\r\n   ```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"map","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"map","statements":["return <any>map(this, f)"],"parameters":[{"name":"f","type":"Function1<V, V2> | Property<V2> | V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Maps values using given function, returning a new\r\n   stream/property. Instead of a function, you can also provide a [Property](property.html),\r\n   in which case each element in the source stream will be mapped to the current value of\r\n   the given property.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[{"parameters":[{"name":"f","type":"Function1<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}},{"parameters":[{"name":"f","type":"Property<V2> | V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}]}},{"name":"merge","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"merge","statements":["assertEventStream(other)","return mergeAll<any>(this as EventStream<any>, other as EventStream<any>).withDesc(new Desc(this, \"merge\", [other]));"],"parameters":[{"name":"other","type":"EventStream<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<any>","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[{"parameters":[{"name":"other","type":"EventStream<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[],"hasOverrideKeyword":false,"docs":[{"kind":24,"description":"\r\n   Merges two streams into one stream that delivers events from both","tags":[]}],"kind":27,"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}},{"parameters":[{"name":"other","type":"EventStream<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V | V2>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}]}},{"name":"not","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"not","statements":["return <any>not(this)"],"parameters":[],"returnType":"EventStream<boolean>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Returns a stream/property that inverts boolean values (using `!`)","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"startWith","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"startWith","statements":["return startWithE(this,seed)"],"parameters":[{"name":"seed","type":"V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Adds a starting value to the stream/property, i.e. concats a\r\n   single-element stream containing the single seed value  with this stream.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"subscribeInternal","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"subscribeInternal","statements":["return this.dispatcher.subscribe(sink)"],"parameters":[{"name":"sink","initializer":"nullSink","type":"EventSink<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"toEventStream","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toEventStream","statements":["return this"],"parameters":[],"typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns this stream.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"toProperty","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toProperty","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"usedInitValue","initializer":"arguments.length\r\n      ? toOption<V>(<any>initValue)\r\n      : none<V>()","type":"Option<V>","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"disp","initializer":"this.dispatcher","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"desc","initializer":"new Desc(this, \"toProperty\", Array.prototype.slice.apply(arguments))","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"streamSubscribe","initializer":"disp.subscribe","hasExclamationToken":false,"kind":40}]},"return new Property(desc, streamSubscribeToPropertySubscribe(usedInitValue, streamSubscribe))"],"parameters":[{"name":"initValue","type":"V","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Creates a Property based on the\r\n   EventStream.\r\n\r\n   Without arguments, you'll get a Property without an initial value.\r\n   The Property will get its first actual value from the stream, and after that it'll\r\n   always have a current value.\r\n\r\n   You can also give an initial value that will be used as the current value until\r\n   the first value comes from the stream.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"transform","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"transform","statements":["return transformE(this, transformer, desc)"],"parameters":[{"name":"transformer","type":"Transformer<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"desc","type":"Desc","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"withLatestFrom","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"withLatestFrom","statements":["return withLatestFromE(this, samplee, f)"],"parameters":[{"name":"samplee","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Function2<V, V2, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<R>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Creates an EventStream/Property by sampling a given `samplee`\r\n   stream/property value at each event from the this stream/property.","tags":[{"kind":25,"tagName":"param","text":"{Observable<V2>} samplee"},{"kind":25,"tagName":"param","text":"f function to select/calculate the result value based on the value in the source stream and the samplee"},{"kind":25,"tagName":"typeparam","text":"V2  type of values in the samplee"},{"kind":25,"tagName":"typeparam","text":"R   type of values in the result"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}},{"name":"withStateMachine","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"withStateMachine","statements":["return <any>withStateMachine<V, State, Out>(initState, f, this)"],"parameters":[{"name":"initState","type":"State","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"StateF<V, State, Out>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<Out>","typeParameters":[{"name":"State","kind":39,"isConst":false,"variance":0},{"name":"Out","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Lets you run a state machine\r\n   on an observable. Give it an initial state object and a state\r\n   transformation function that processes each incoming event and\r\n   returns an array containing the next state and an array of output\r\n   events. Here's an example where we calculate the total sum of all\r\n   numbers in the stream and output the value on stream end:\r\n\r\n   ```js\r\n   Bacon.fromArray([1,2,3])\r\n   .withStateMachine(0, function(sum, event) {\r\n    if (event.hasValue)\r\n      return [sum + event.value, []]\r\n    else if (event.isEnd)\r\n      return [undefined, [new Bacon.Next(sum), event]]\r\n    else\r\n      return [sum, [event]]\r\n  })\r\n   ```","tags":[{"kind":25,"tagName":"param","text":"initState  initial state for the state machine"},{"kind":25,"tagName":"param","text":"f          the function that defines the state machine"},{"kind":25,"tagName":"typeparam","text":" State   type of machine state"},{"kind":25,"tagName":"typeparam","text":" Out     type of values to be emitted"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"EventStream","modulePath":"..\\src\\observable.ts"}}}]},"Observable":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"awaiting","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"awaiting","statements":["return awaiting(this, other)"],"parameters":[{"name":"other","type":"Observable<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<boolean>","typeParameters":[],"docs":[{"kind":24,"description":"\r\nCreates a Property that indicates whether\r\n`observable` is awaiting `otherObservable`, i.e. has produced a value after the latest\r\nvalue from `otherObservable`. This is handy for keeping track whether we are\r\ncurrently awaiting an AJAX response:\r\n\r\n```js\r\nvar showAjaxIndicator = ajaxRequest.awaiting(ajaxResponse)\r\n```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"bufferingThrottle","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"bufferingThrottle","statements":["return <any>bufferingThrottle(this, minimumInterval)"],"parameters":[{"name":"minimumInterval","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nThrottles the observable using a buffer so that at most one value event in minimumInterval is issued.\r\nUnlike [`throttle`](#observable-throttle), it doesn't discard the excessive events but buffers them instead, outputting\r\nthem with a rate of at most one value per minimumInterval.\r\n\r\nExample:\r\n\r\n```js\r\nvar throttled = source.bufferingThrottle(2)\r\n```\r\n\r\n```\r\nsource:    asdf----asdf----\r\nthrottled: a-s-d-f-a-s-d-f-\r\n```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"combine","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"combine","statements":["return combineTwo(this, right, f).withDesc(new Desc(this, \"combine\", [right, f]))"],"parameters":[{"name":"right","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Function2<V, V2, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nCombines the latest values of the two\r\nstreams or properties using a two-arg function. Similarly to [`scan`](#scan), you can use a\r\nmethod name instead, so you could do `a.combine(b, \".concat\")` for two\r\nproperties with array value. The result is a [Property](property.html).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"debounce","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"debounce","statements":["return <any>debounce(this, minimumInterval)"],"parameters":[{"name":"minimumInterval","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nThrottles stream/property by given amount\r\nof milliseconds, but so that event is only emitted after the given\r\n\"quiet period\". Does not affect emitting the initial value of a [Property](property.html).\r\nThe difference of [`throttle`](#throttle) and [`debounce`](#debounce) is the same as it is in the\r\nsame methods in jQuery.\r\n\r\nExample:\r\n\r\n```\r\nsource:             asdf----asdf----\r\nsource.debounce(2): -----f-------f--\r\n```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"debounceImmediate","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"debounceImmediate","statements":["return <any>debounceImmediate(this, minimumInterval)"],"parameters":[{"name":"minimumInterval","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nPasses the first event in the\r\nstream through, but after that, only passes events after a given number\r\nof milliseconds have passed since previous output.\r\n\r\nExample:\r\n\r\n```\r\nsource:                      asdf----asdf----\r\nsource.debounceImmediate(2): a-d-----a-d-----\r\n```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"decode","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"decode","statements":["return decode(<any>this, cases)"],"parameters":[{"name":"cases","type":"T","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<DecodedValueOf<T>>","typeParameters":[{"name":"T","kind":39,"isConst":false,"constraint":"Record<any, any>","variance":0}],"docs":[{"kind":24,"description":"\r\nDecodes input using the given mapping. Is a\r\nbit like a switch-case or the decode function in Oracle SQL. For\r\nexample, the following would map the value 1 into the string \"mike\"\r\nand the value 2 into the value of the `who` property.\r\n\r\n```js\r\nproperty.decode({1 : \"mike\", 2 : who})\r\n```\r\n\r\nThis is actually based on [`combineTemplate`](#combinetemplate) so you can compose static\r\nand dynamic data quite freely, as in\r\n\r\n```js\r\nproperty.decode({1 : { type: \"mike\" }, 2 : { type: \"other\", whoThen : who }})\r\n```\r\n\r\nThe return value of [`decode`](#decode) is always a [`Property`](property.html).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"delay","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"delay","statements":["return <any>delay(this, delayMs)"],"parameters":[{"name":"delayMs","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nDelays the stream/property by given amount of milliseconds. Does not delay the initial value of a [`Property`](property.html).\r\n\r\n```js\r\nvar delayed = source.delay(2)\r\n```\r\n\r\n```\r\nsource:    asdf----asdf----\r\ndelayed:   --asdf----asdf--\r\n```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"deps","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"deps","statements":["return this.desc.deps()"],"parameters":[],"returnType":"Observable<any>[]","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns the an array of dependencies that the Observable has. For instance, for `a.map(function() {}).deps()`, would return `[a]`.\r\n   This method returns the \"visible\" dependencies only, skipping internal details.  This method is thus suitable for visualization tools.\r\n   Internally, many combinator functions depend on other combinators to create intermediate Observables that the result will actually depend on.\r\n   The `deps` method will skip these internal dependencies. See also: [internalDeps](#internaldeps)","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"diff","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"diff","statements":["return diff(this, start, f)"],"parameters":[{"name":"start","type":"V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Differ<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nReturns a Property that represents the result of a comparison\r\nbetween the previous and current value of the Observable. For the initial value of the Observable,\r\nthe previous value will be the given start.\r\n\r\nExample:\r\n\r\n```js\r\nvar distance = function (a,b) { return Math.abs(b - a) }\r\nBacon.sequentially(1, [1,2,3]).diff(0, distance)\r\n```\r\n\r\nThis would result to following elements in the result stream:\r\n\r\n    1 - 0 = 1\r\n    2 - 1 = 1\r\n    3 - 2 = 1","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"doAction","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"doAction","statements":["return <any>this.transform(doActionT(f), new Desc(this, \"doAction\", [f]))"],"parameters":[{"name":"f","type":"Function1<V, any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a stream/property where the function f\r\nis executed for each value, before dispatching to subscribers. This is\r\nuseful for debugging, but also for stuff like calling the\r\n`preventDefault()` method for events. In fact, you can\r\nalso use a property-extractor string instead of a function, as in\r\n`\".preventDefault\"`.\r\n\r\nPlease note that for Properties, it's not guaranteed that the function will be called exactly once\r\nper event; when a Property loses all of its subscribers it will re-emit its current value when a \r\nnew subscriber is added.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"doEnd","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"doEnd","statements":["return <any>this.transform(doEndT(f), new Desc(this, \"doEnd\", [f]))"],"parameters":[{"name":"f","type":"Function0<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"doError","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"doError","statements":["return <any>this.transform(doErrorT(f), new Desc(this, \"doError\", [f]))"],"parameters":[{"name":"f","type":"Function1<any, any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a stream/property where the function f\r\nis executed for each error, before dispatching to subscribers.\r\nThat is, same as [`doAction`](#observable-doaction) but for errors.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"doLog","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"doLog","statements":["return <any>this.transform(doLogT<V>(args), new Desc(this, \"doLog\", args))"],"parameters":[{"name":"args","type":"any[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nLogs each value of the Observable to the console. doLog() behaves like [`log`](#log)\r\nbut does not subscribe to the event stream. You can think of doLog() as a\r\nlogger function that – unlike log() – is safe to use in production. doLog() is\r\nsafe, because it does not cause the same surprising side-effects as log()\r\ndoes.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"endAsValue","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"endAsValue","statements":["return endAsValue(this)"],"parameters":[],"returnType":"Observable<{}>","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"endOnError","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"endOnError","statements":["return <any>endOnError(this, predicate)"],"parameters":[{"name":"predicate","initializer":"x => true","type":"Predicate<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a stream/property that ends the on first [`Error`](error.html) event. The\r\nerror is included in the output of the returned Observable.","tags":[{"kind":25,"tagName":"param","text":" predicate   optional predicate function to determine whether to end on a given error"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"errors","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"errors","statements":["return this.filter(x => false).withDesc(new Desc(this, \"errors\"))"],"parameters":[],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a stream containing [`Error`](error.html) events only.\r\nSame as filtering with a function that always returns false.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"filter","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"filter","statements":["return <any>filter(this, f)"],"parameters":[{"name":"f","type":"Predicate<V> | boolean | Property<boolean>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nFilters values using given predicate function.\r\nInstead of a function, you can use a constant value (`true` to include all, `false` to exclude all).\r\n\r\nYou can also filter values based on the value of a\r\nproperty. Event will be included in output [if and only if](http://en.wikipedia.org/wiki/If_and_only_if) the property holds `true`\r\nat the time of the event.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"first","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"first","statements":["return <any>take(1, this, new Desc(this, \"first\"))"],"parameters":[],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nTakes the first element from the stream. Essentially `observable.take(1)`.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"firstToPromise","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"firstToPromise","statements":["return firstToPromise(this, PromiseCtr)"],"parameters":[{"name":"PromiseCtr","type":"Function","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Promise<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a Promise which will be resolved with the first event coming from an Observable.\r\nLike [`toPromise`](#topromise), the global ES6 promise implementation will be used unless a promise\r\nconstructor is given.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"fold","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"fold","statements":["return fold(this, seed, f)"],"parameters":[{"name":"seed","type":"V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Accumulator<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nWorks like [`scan`](#scan) but only emits the final\r\nvalue, i.e. the value just before the observable ends. Returns a\r\n[`Property`](property.html).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"forEach","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"forEach","statements":["return this.onValue(f)"],"parameters":[{"name":"f","initializer":"nullSink","type":"Sink<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   An alias for [onValue](#onvalue).\r\n\r\n   Subscribes a given handler function to the observable. Function will be called for each new value (not for errors or stream end).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"holdWhen","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"holdWhen","statements":["return holdWhen(this, valve)"],"parameters":[{"name":"valve","type":"Property<boolean>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\nPauses and buffers the event stream if last event in valve is truthy.\r\nAll buffered events are released when valve becomes falsy.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"inspect","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"inspect","statements":["return this.toString()"],"parameters":[],"typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"internalDeps","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"internalDeps","statements":["return this.initialDesc.deps();"],"parameters":[],"returnType":"any[]","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns the true dependencies of the observable, including the intermediate \"hidden\" Observables.\r\n   This method is for Bacon.js internal purposes but could be useful for debugging/analysis tools as well.\r\n   See also: [deps](#deps)","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"last","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"last","statements":["return <any>last(this)"],"parameters":[],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nTakes the last element from the stream. None, if stream is empty.\r\n\r\n\r\nNote:* `neverEndingStream.last()` creates the stream which doesn't produce any events and never ends.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"log","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"log","statements":["log(args, this)","return this"],"parameters":[{"name":"args","type":"any[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nLogs each value of the Observable to the console.\r\nIt optionally takes arguments to pass to console.log() alongside each\r\nvalue. To assist with chaining, it returns the original Observable. Note\r\nthat as a side-effect, the observable will have a constant listener and\r\nwill not be garbage-collected. So, use this for debugging only and\r\nremove from production code. For example:\r\n\r\n```js\r\nmyStream.log(\"New event in myStream\")\r\n```\r\n\r\nor just\r\n\r\n```js\r\nmyStream.log()\r\n```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"mapEnd","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"mapEnd","statements":["return <any>this.transform(mapEndT(f), new Desc(this, \"mapEnd\", [f]))"],"parameters":[{"name":"f","type":"Function0<V> | V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nAdds an extra [`Next`](next.html) event just before End. The value is created\r\nby calling the given function when the source stream ends. Instead of a\r\nfunction, a static value can be used.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"mapError","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"mapError","statements":["return <any>this.transform(mapErrorT(f), new Desc(this, \"mapError\", [f]))"],"parameters":[{"name":"f","type":"Function1<any, V> | V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nMaps errors using given function. More\r\nspecifically, feeds the \"error\" field of the error event to the function\r\nand produces a [`Next`](next.html) event based on the return value.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"name","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"name","statements":["this._name = name;","return this;"],"parameters":[{"name":"name","type":"string","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[{"kind":24,"description":"\r\nSets the name of the observable. Overrides the default\r\nimplementation of [`toString`](#tostring) and `inspect`.\r\nReturns the same observable, with mutated name.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"onEnd","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"onEnd","statements":["return this.subscribe(function(event) {\r\n  if (event.isEnd) { return f(); }\r\n  return more\r\n});"],"parameters":[{"name":"f","initializer":"nullVoidSink","type":"VoidSink","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"\r\nSubscribes a callback to stream end. The function will be called when the stream ends.\r\nJust like `subscribe`, this method returns a function for unsubscribing.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"onError","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"onError","statements":["return this.subscribe(function(event) {\r\n  if (isError(event)) { return f(event.error) }\r\n  return more\r\n})"],"parameters":[{"name":"f","initializer":"nullSink","type":"Sink<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"\r\nSubscribes a handler to error events. The function will be called for each error in the stream.\r\nJust like `subscribe`, this method returns a function for unsubscribing.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"onValue","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"onValue","statements":["return this.subscribe(function(event) {\r\n  if (hasValue(event)) { return f(event.value) }\r\n  return more\r\n});"],"parameters":[{"name":"f","initializer":"nullSink","type":"Sink<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"\r\nSubscribes a given handler function to the observable. Function will be called for each new value.\r\nThis is the simplest way to assign a side-effect to an observable. The difference\r\nto the `subscribe` method is that the actual stream values are\r\nreceived, instead of [`Event`](event) objects.\r\nJust like `subscribe`, this method returns a function for unsubscribing.\r\n`stream.onValue` and `property.onValue` behave similarly, except that the latter also\r\npushes the initial value of the property, in case there is one.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"onValues","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"onValues","statements":["return this.onValue(function(args) { return f(...(<any>args)) });"],"parameters":[{"name":"f","type":"Function","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"\r\nLike [`onValue`](#onvalue), but splits the value (assuming its an array) as function arguments to `f`.\r\nOnly applicable for observables with arrays as values.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"reduce","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"reduce","statements":["return fold(this, seed, f)"],"parameters":[{"name":"seed","type":"V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Accumulator<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"A synonym for [scan](#scan).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"sampledBy","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"sampledBy","statements":["return sampledBy(this, sampler, arguments[1])"],"parameters":[{"name":"sampler","type":"Observable<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Observable<V>","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[{"parameters":[{"name":"sampler","type":"EventStream<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[],"hasOverrideKeyword":false,"docs":[{"kind":24,"description":"\r\n  Creates an EventStream by sampling this\r\n  stream/property value at each event from the `sampler` stream. The result\r\n  `EventStream` will contain the sampled value at each event in the source\r\n  stream.","tags":[{"kind":25,"tagName":"param","text":"{Observable<V2>} sampler"}]},{"kind":24,"description":"\r\n   Creates an EventStream/Property by sampling this\r\n   stream/property value at each event from the `sampler` stream. The result\r\n   will contain the sampled value at each event in the source stream.","tags":[{"kind":25,"tagName":"param","text":"{Observable<V2>} sampler"}]}],"kind":27,"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}},{"parameters":[{"name":"sampler","type":"Property<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}},{"parameters":[{"name":"sampler","type":"Observable<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Observable<V>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}]}},{"name":"scan","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"scan","statements":["return scan(this, seed, f)"],"parameters":[{"name":"seed","type":"V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Accumulator<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nScans stream/property with given seed value and\r\naccumulator function, resulting to a Property. For example, you might\r\nuse zero as seed and a \"plus\" function as the accumulator to create\r\nan \"integral\" property. Instead of a function, you can also supply a\r\nmethod name such as \".concat\", in which case this method is called on\r\nthe accumulator value and the new stream value is used as argument.\r\n\r\nExample:\r\n\r\n```js\r\nvar plus = function (a,b) { return a + b }\r\nBacon.sequentially(1, [1,2,3]).scan(0, plus)\r\n```\r\n\r\nThis would result to following elements in the result stream:\r\n\r\n    seed value = 0\r\n    0 + 1 = 1\r\n    1 + 2 = 3\r\n    3 + 3 = 6\r\n\r\nWhen applied to a Property as in `r = p.scan(seed, f)`, there's a (hopefully insignificant) catch:\r\nThe starting value for `r` depends on whether `p` has an\r\ninitial value when scan is applied. If there's no initial value, this works\r\nidentically to EventStream.scan: the `seed` will be the initial value of\r\n`r`. However, if `r` already has a current/initial value `x`, the\r\nseed won't be output as is. Instead, the initial value of `r` will be `f(seed, x)`. This makes sense,\r\nbecause there can only be 1 initial value for a Property at a time.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"skip","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"skip","statements":["return <any>skip(this, count)"],"parameters":[{"name":"count","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nSkips the first n elements from the stream","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"skipDuplicates","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"skipDuplicates","statements":["return <any>skipDuplicates(this, isEqual)"],"parameters":[{"name":"isEqual","type":"Equals<V>","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nDrops consecutive equal elements. So,\r\nfrom `[1, 2, 2, 1]` you'd get `[1, 2, 1]`. Uses the `===` operator for equality\r\nchecking by default. If the isEqual argument is supplied, checks by calling\r\nisEqual(oldValue, newValue). For instance, to do a deep comparison,you can\r\nuse the isEqual function from [underscore.js](http://underscorejs.org/)\r\nlike `stream.skipDuplicates(_.isEqual)`.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"skipErrors","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"skipErrors","statements":["return <any>skipErrors(this)"],"parameters":[],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a new stream/property which excludes all [Error](error.html) events in the source","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"skipUntil","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"skipUntil","statements":["return <any>skipUntil(this, starter)"],"parameters":[{"name":"starter","type":"Observable<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Skips elements from the source, until a value event\r\n   appears in the given `starter` stream/property. In other words, starts delivering values\r\n   from the source after first value appears in `starter`.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"skipWhile","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"skipWhile","statements":["return <any>skipWhile(this, f)"],"parameters":[{"name":"f","type":"PredicateOrProperty<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Skips elements until the given predicate function returns falsy once, and then\r\n   lets all events pass through. Instead of a predicate you can also pass in a `Property<boolean>` to skip elements\r\n   while the Property holds a truthy value.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"slidingWindow","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"slidingWindow","statements":["return slidingWindow(this, maxValues, minValues)"],"parameters":[{"name":"maxValues","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"minValues","initializer":"0","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V[]>","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a Property that represents a\r\n\"sliding window\" into the history of the values of the Observable. The\r\nresult Property will have a value that is an array containing the last `n`\r\nvalues of the original observable, where `n` is at most the value of the\r\n`max` argument, and at least the value of the `min` argument. If the\r\n`min` argument is omitted, there's no lower limit of values.\r\n\r\nFor example, if you have a stream `s` with value a sequence 1 - 2 - 3 - 4 - 5, the\r\nrespective values in `s.slidingWindow(2)` would be [] - [1] - [1,2] -\r\n[2,3] - [3,4] - [4,5]. The values of `s.slidingWindow(2,2)`would be\r\n[1,2] - [2,3] - [3,4] - [4,5].","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"subscribe","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"subscribe","statements":["return UpdateBarrier.wrappedSubscribe(this, sink => this.subscribeInternal(sink), sink)"],"parameters":[{"name":"sink","initializer":"nullSink","type":"EventSink<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"\r\nsubscribes given handler function to event stream. Function will receive [event](event.html) objects\r\n   for all new value, end and error events in the stream.\r\n   The subscribe() call returns a `unsubscribe` function that you can call to unsubscribe.\r\n   You can also unsubscribe by returning [`Bacon.noMore`](../globals.html#nomore) from the handler function as a reply\r\n   to an Event.\r\n   `stream.subscribe` and `property.subscribe` behave similarly, except that the latter also\r\n   pushes the initial value of the property, in case there is one.","tags":[{"kind":25,"tagName":"param","text":"{EventSink<V>} sink the handler function"},{"kind":25,"tagName":"returns","text":"{Unsub}"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"take","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"take","statements":["return <any>take(count, this)"],"parameters":[{"name":"count","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nTakes at most n values from the stream and then ends the stream. If the stream has\r\nfewer than n values then it is unaffected.\r\nEqual to [`Bacon.never()`](../globals.html#never) if `n <= 0`.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"takeUntil","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"takeUntil","statements":["return <any>takeUntil(this, stopper)"],"parameters":[{"name":"stopper","type":"Observable<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nTakes elements from source until a value event appears in the other stream.\r\nIf other stream ends without value, it is ignored.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"takeWhile","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"takeWhile","statements":["return <any>takeWhile(this, f)"],"parameters":[{"name":"f","type":"PredicateOrProperty<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nTakes while given predicate function holds true, and then ends. Alternatively, you can supply a boolean Property to take elements while the Property holds `true`.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"throttle","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"throttle","statements":["return <any>throttle(this, minimumInterval)"],"parameters":[{"name":"minimumInterval","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"\r\nThrottles stream/property by given amount\r\nof milliseconds. Events are emitted with the minimum interval of\r\n[`delay`](#observable-delay). The implementation is based on [`stream.bufferWithTime`](#stream-bufferwithtime).\r\nDoes not affect emitting the initial value of a [`Property`](#property).\r\n\r\nExample:\r\n\r\n```js\r\nvar throttled = source.throttle(2)\r\n```\r\n\r\n```\r\nsource:    asdf----asdf----\r\nthrottled: --s--f----s--f--\r\n```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"toPromise","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toPromise","statements":["return toPromise(this, PromiseCtr)"],"parameters":[{"name":"PromiseCtr","type":"Function","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Promise<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a Promise which will be resolved with the last event coming from an Observable.\r\nThe global ES6 promise implementation will be used unless a promise constructor is given.\r\nUse a shim if you need to support legacy browsers or platforms.\r\n[caniuse promises](http://caniuse.com/#feat=promises).\r\n\r\nSee also [firstToPromise](#firsttopromise).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"toString","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toString","statements":["if (this._name) {\r\n  return this._name;\r\n} else {\r\n  return this.desc.toString();\r\n}"],"parameters":[],"returnType":"string","typeParameters":[],"docs":[{"kind":24,"description":"\r\nReturns a textual description of the Observable. For instance, `Bacon.once(1).map(function() {}).toString()` would return \"Bacon.once(1).map(function)\".","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"withDesc","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"withDesc","statements":["if (desc) this.desc = desc;","return this;"],"parameters":[{"name":"desc","type":"Desc","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"withDescription","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"withDescription","statements":["this.desc = describe(context, method, ...args);","return this;"],"parameters":[{"name":"context","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"method","type":"string","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"args","type":"any[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"typeParameters":[],"docs":[{"kind":24,"description":"\r\nSets the structured description of the observable. The [`toString`](#tostring) and `inspect` methods\r\nuse this data recursively to create a string representation for the observable. This method\r\nis probably useful for Bacon core / library / plugin development only.\r\n\r\nFor example:\r\n\r\n    var src = Bacon.once(1)\r\n    var obs = src.map(function(x) { return -x })\r\n    console.log(obs.toString())\r\n    --> Bacon.once(1).map(function)\r\n    obs.withDescription(src, \"times\", -1)\r\n    console.log(obs.toString())\r\n    --> Bacon.once(1).times(-1)\r\n\r\nThe method returns the same observable with mutated description.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}},{"name":"zip","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"zip","statements":["return zip(this, other, f)"],"parameters":[{"name":"other","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Function2<V, V2, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<R>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nReturns an EventStream with elements\r\npair-wise lined up with events from this and the other EventStream or Property.\r\nA zipped stream will publish only when it has a value from each\r\nsource and will only produce values up to when any single source ends.\r\n\r\nThe given function `f` is used to create the result value from value in the two\r\nsources. If no function is given, the values are zipped into an array.\r\n\r\nBe careful not to have too much \"drift\" between streams. If one stream\r\nproduces many more values than some other excessive buffering will\r\noccur inside the zipped observable.\r\n\r\nExample 1:\r\n\r\n```js\r\nvar x = Bacon.fromArray([1, 2])\r\nvar y = Bacon.fromArray([3, 4])\r\nx.zip(y, function(x, y) { return x + y })\r\n\r\n# produces values 4, 6\r\n```\r\n\r\nSee also [`zipWith`](../globals.html#zipwith) and [`zipAsArray`](../globals.html/zipasarray) for zipping more than 2 sources.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Observable","modulePath":"..\\src\\observable.ts"}}}]},"Property":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"and","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"and","statements":["return and(this, other)"],"parameters":[{"name":"other","type":"Property<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<boolean>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Combines properties with the `&&` operator. It produces a new value when either of the Properties change,\r\n   combining the latest values using `&&`.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"changes","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"changes","statements":["return new EventStream(\r\n  new Desc(this, \"changes\", []),\r\n  (sink) => this.dispatcher.subscribe(function (event: Event<V>) {\r\n    if (!event.isInitial) {\r\n      return sink(event);\r\n    }\r\n    return more\r\n  })\r\n)"],"parameters":[],"returnType":"EventStream<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\ncreates a stream of changes to the Property. The stream *does not* include\r\n   an event for the current value of the Property at the time this method was called.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"concat","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"concat","statements":["return this.transformChanges(describe(this, \"concat\", other), changes => changes.concat(other))"],"parameters":[{"name":"other","type":"Observable<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<any>","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[{"parameters":[{"name":"other","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[],"hasOverrideKeyword":false,"docs":[{"kind":24,"description":"\r\n   Concatenates this property with another stream/properties into one property so that\r\n   it will deliver events from this property it ends and then deliver\r\n   events from `other`. This means too that events from `other`,\r\n   occurring before the end of this property will not be included in the result\r\n   stream/property.","tags":[]}],"kind":27,"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}},{"parameters":[{"name":"other","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V | V2>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}]}},{"name":"transformChanges","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"transformChanges","statements":["return <any>transformPropertyChanges(this, f, desc)"],"parameters":[{"name":"desc","type":"Desc","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"EventStreamDelay<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"this","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMap","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMap","statements":["return <any>flatMap(this, f)"],"parameters":[{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   For each element in the source stream, spawn a new\r\n   stream/property using the function `f`. Collect events from each of the spawned\r\n   streams into the result property. Note that instead of a function, you can provide a\r\n   stream/property too. Also, the return value of function `f` can be either an\r\n   `Observable` (stream/property) or a constant value.\r\n\r\n   `stream.flatMap()` can be used conveniently with [`Bacon.once()`](../globals.html#once) and [`Bacon.never()`](../globals.html#never)\r\n   for converting and filtering at the same time, including only some of the results.\r\n\r\n   Example - converting strings to integers, skipping empty values:\r\n\r\n   ```js\r\n   stream.flatMap(function(text) {\r\n    return (text != \"\") ? parseInt(text) : Bacon.never()\r\n})\r\n   ```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapConcat","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapConcat","statements":["return <any>flatMapConcat(this, f)"],"parameters":[{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   A [`flatMapWithConcurrencyLimit`](#flatmapwithconcurrencylimit) with limit of 1.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapError","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapError","statements":["return <any>flatMapError(this, f)"],"parameters":[{"name":"f","type":"Function1<any, Observable<V2> | EventOrValue<V2>>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V | V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Like [`flatMap`](#flatmap), but is applied only on [`Error`](error.html) events. Returned values go into the\r\n   value stream, unless an error event is returned. As an example, one type of error could result in a retry and another just\r\n   passed through, which can be implemented using flatMapError.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapEvent","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapEvent","statements":["return <any>flatMapEvent(this, f)"],"parameters":[{"name":"f","type":"EventSpawner<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapFirst","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapFirst","statements":["return <any>flatMapFirst(this, f)"],"parameters":[{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Like [`flatMap`](#observable-flatmap), but only spawns a new\r\n   stream if the previously spawned stream has ended.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapLatest","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapLatest","statements":["return <any>flatMapLatest(this, f)"],"parameters":[{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Like [`flatMap`](#flatmap), but instead of including events from\r\n   all spawned streams, only includes them from the latest spawned stream.\r\n   You can think this as switching from stream to stream.\r\n   Note that instead of a function, you can provide a stream/property too.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"flatMapWithConcurrencyLimit","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"flatMapWithConcurrencyLimit","statements":["return <any>flatMapWithConcurrencyLimit(this, limit, f)"],"parameters":[{"name":"limit","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"SpawnerOrObservable<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   A super method of *flatMap* family. It limits the number of open spawned streams and buffers incoming events.\r\n   [`flatMapConcat`](#flatmapconcat) is `flatMapWithConcurrencyLimit(1)` (only one input active),\r\n   and [`flatMap`](#flatmap) is `flatMapWithConcurrencyLimit ∞` (all inputs are piped to output).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"groupBy","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"groupBy","statements":["return <any>groupBy<V, V2>(this, keyF, limitF)"],"parameters":[{"name":"keyF","type":"Function1<V, string>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"limitF","type":"GroupTransformer<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<EventStream<V2>>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"default":"V","variance":0}],"docs":[{"kind":24,"description":"\r\n   Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped\r\n   stream life. Stream transformed by `limitF` is passed on if provided. `limitF` gets grouped stream\r\n   and the original event causing the stream to start as parameters.\r\n\r\n   Calculator for grouped consecutive values until group is cancelled:\r\n\r\n   ```\r\n   var events = [\r\n   {id: 1, type: \"add\", val: 3 },\r\n   {id: 2, type: \"add\", val: -1 },\r\n   {id: 1, type: \"add\", val: 2 },\r\n   {id: 2, type: \"cancel\"},\r\n   {id: 3, type: \"add\", val: 2 },\r\n   {id: 3, type: \"cancel\"},\r\n   {id: 1, type: \"add\", val: 1 },\r\n   {id: 1, type: \"add\", val: 2 },\r\n   {id: 1, type: \"cancel\"}\r\n   ]\r\n\r\n   function keyF(event) {\r\n  return event.id\r\n}\r\n\r\n   function limitF(groupedStream, groupStartingEvent) {\r\n  var cancel = groupedStream.filter(function(x) { return x.type === \"cancel\"}).take(1)\r\n  var adds = groupedStream.filter(function(x) { return x.type === \"add\" })\r\n  return adds.takeUntil(cancel).map(\".val\")\r\n}\r\n\r\n   Bacon.sequentially(2, events)\r\n   .groupBy(keyF, limitF)\r\n   .flatMap(function(groupedStream) {\r\n    return groupedStream.fold(0, function(acc, x) { return acc + x })\r\n  })\r\n   .onValue(function(sum) {\r\n    console.log(sum)\r\n    // returns [-1, 2, 8] in an order\r\n  })\r\n   ```","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"map","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"map","statements":["return <any>map<V, V2>(this, f)"],"parameters":[{"name":"f","type":"Function1<V, V2> | Property<V2> | V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Maps values using given function, returning a new\r\n   stream/property. Instead of a function, you can also provide a [Property](property.html),\r\n   in which case each element in the source stream will be mapped to the current value of\r\n   the given property.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[{"parameters":[{"name":"f","type":"Function1<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}},{"parameters":[{"name":"f","type":"Property<V2> | V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"hasOverrideKeyword":false,"docs":[],"kind":27,"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}]}},{"name":"not","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"not","statements":["return <any>not(this)"],"parameters":[],"returnType":"Property<boolean>","typeParameters":[],"docs":[{"kind":24,"description":"Returns a Property that inverts the value of this one (using the `!` operator).","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"or","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"or","statements":["return or(this, other)"],"parameters":[{"name":"other","type":"Property<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<boolean>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Combines properties with the `||` operator. It produces a new value when either of the Properties change,\r\n   combining the latest values using `||`.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"sample","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"sample","statements":["return sampleP(this, interval)"],"parameters":[{"name":"interval","type":"number","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Creates an EventStream by sampling the\r\n   property value at given interval (in milliseconds)","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"startWith","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"startWith","statements":["return startWithP(this, seed)"],"parameters":[{"name":"seed","type":"V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n  Adds an initial \"default\" value for the\r\n  Property. If the Property doesn't have an initial value of it's own, the\r\n  given value will be used as the initial value. If the property has an\r\n  initial value of its own, the given value will be ignored.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"subscribeInternal","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"subscribeInternal","statements":["return this.dispatcher.subscribe(sink)"],"parameters":[{"name":"sink","initializer":"nullSink","type":"EventSink<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Unsub","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"toEventStream","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toEventStream","statements":["return new EventStream(\r\n  new Desc(this, \"toEventStream\", []),\r\n  (sink) => this.subscribeInternal(function (event) {\r\n    return sink(event.toNext());\r\n  }),\r\n  undefined,\r\n  options\r\n);"],"parameters":[{"name":"options","type":"EventStreamOptions","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventStream<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Creates an EventStream based on this Property. The stream contains also an event for the current\r\n   value of this Property at the time this method was called.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"toProperty","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toProperty","statements":["assertNoArguments(arguments);","return this;"],"parameters":[],"returnType":"Property<V>","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Returns the Property itself.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"transform","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"transform","statements":["return transformP(this, transformer, desc)"],"parameters":[{"name":"transformer","type":"Transformer<V, V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"desc","type":"Desc","isReadonly":false,"decorators":[],"hasQuestionToken":true,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"withLatestFrom","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"withLatestFrom","statements":["return withLatestFromP(this, samplee, f)"],"parameters":[{"name":"samplee","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Function2<V, V2, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Creates an EventStream/Property by sampling a given `samplee`\r\n   stream/property value at each event from the this stream/property.","tags":[{"kind":25,"tagName":"param","text":"{Observable<V2>} samplee"},{"kind":25,"tagName":"param","text":"f function to select/calculate the result value based on the value in the source stream and the samplee"},{"kind":25,"tagName":"typeparam","text":"V2  type of values in the samplee"},{"kind":25,"tagName":"typeparam","text":"R   type of values in the result"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}},{"name":"withStateMachine","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"withStateMachine","statements":["return <any>withStateMachine<V, State, Out>(initState, f, this)"],"parameters":[{"name":"initState","type":"State","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"StateF<V, State, Out>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<Out>","typeParameters":[{"name":"State","kind":39,"isConst":false,"variance":0},{"name":"Out","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n   Lets you run a state machine\r\n   on an observable. Give it an initial state object and a state\r\n   transformation function that processes each incoming event and\r\n   returns an array containing the next state and an array of output\r\n   events. Here's an example where we calculate the total sum of all\r\n   numbers in the stream and output the value on stream end:\r\n\r\n   ```js\r\n   Bacon.fromArray([1,2,3])\r\n   .withStateMachine(0, function(sum, event) {\r\n    if (event.hasValue)\r\n      return [sum + event.value, []]\r\n    else if (event.isEnd)\r\n      return [undefined, [new Bacon.Next(sum), event]]\r\n    else\r\n      return [sum, [event]]\r\n  })\r\n   ```","tags":[{"kind":25,"tagName":"param","text":"initState  initial state for the state machine"},{"kind":25,"tagName":"param","text":"f          the function that defines the state machine"},{"kind":25,"tagName":"typeparam","text":" State   type of machine state"},{"kind":25,"tagName":"typeparam","text":" Out     type of values to be emitted"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Property","modulePath":"..\\src\\observable.ts"}}}]}},"usabilityResult":{"index":0}},"..\\src\\bus.ts":{"moduleComponents":{"Bus":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"plug","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"plug","statements":["assertObservable(input);","if (this.ended) { return; }",{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"sub","initializer":"{ input: input as any as Observable<V>, unsub: undefined }","hasExclamationToken":false,"kind":40}]},"this.subscriptions.push(sub);","if (typeof this.sink !== \"undefined\") { this.subscribeInput(sub); }","return (() => this.unsubscribeInput(input));"],"parameters":[{"name":"input","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[{"name":"V2","kind":39,"isConst":false,"constraint":"V","variance":0}],"docs":[{"kind":24,"description":"\r\n   Plugs the given stream as an input to the Bus. All events from\r\n   the given stream will be delivered to the subscribers of the Bus.\r\n   Returns a function that can be used to unplug the same stream.\r\n\r\n   The plug method practically allows you to merge in other streams after\r\n   the creation of the Bus.","tags":[{"kind":25,"tagName":"returns","text":"a function that can be called to \"unplug\" the source from Bus."}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}},{"name":"end","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"end","statements":["this.ended = true;","this.unsubAll();","if (typeof this.sink === \"function\") { return this.sink(endEvent()); }"],"parameters":[],"returnType":"Reply","typeParameters":[],"docs":[{"kind":24,"description":"\r\n   Ends the stream. Sends an [End](end.html) event to all subscribers.\r\n   After this call, there'll be no more events to the subscribers.\r\n   Also, the [`push`](#push), [`error`](#error) and [`plug`](#plug) methods have no effect.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}},{"name":"push","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"push","statements":["if (!this.ended && typeof this.sink === \"function\") {\r\n  var rootPush = !this.pushing\r\n  if (!rootPush) {\r\n    //console.log(\"recursive push\")\r\n    if (!this.pushQueue) this.pushQueue = []\r\n    this.pushQueue.push(value)\r\n    //console.log('queued', value)\r\n    return\r\n  }\r\n  this.pushing = true\r\n  try {\r\n    return this.sink(nextEvent(value));\r\n  } finally {\r\n    if (rootPush && this.pushQueue) {\r\n      //console.log(\"start processing queue\", this.pushQueue.length)\r\n      var i = 0\r\n      while (i < this.pushQueue.length) {\r\n        //console.log(\"in loop\", i, this.pushQueue[i])\r\n        var v = this.pushQueue[i]\r\n        this.sink(nextEvent(v))\r\n        i++\r\n      }\r\n      this.pushQueue = undefined\r\n    }\r\n    this.pushing = false\r\n  }\r\n}"],"parameters":[{"name":"value","type":"V","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Reply","typeParameters":[],"docs":[{"kind":24,"description":"\r\nPushes a new value to the stream.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}},{"name":"error","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"error","statements":["if (typeof this.sink === \"function\") { return this.sink(new Error(error)); }"],"parameters":[{"name":"error","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Reply","typeParameters":[],"docs":[{"kind":24,"description":"\r\nPushes an error to this stream.","tags":[]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}},{"name":"unsubAll","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"unsubAll","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"iterable","initializer":"this.subscriptions","hasExclamationToken":false,"kind":40}]},"for (var i = 0, sub; i < iterable.length; i++) {\r\n  sub = iterable[i];\r\n  if (typeof sub.unsub === \"function\") { sub.unsub(); }\r\n}"],"parameters":[],"typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}},{"name":"subscribeAll","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"subscribeAll","statements":["if (this.ended) {\r\n  newSink(endEvent());\r\n} else {\r\n  this.sink = newSink;\r\n  var iterable = this.subscriptions.slice();\r\n  for (var i = 0, subscription; i < iterable.length; i++) {\r\n    subscription = iterable[i];\r\n    this.subscribeInput(subscription);\r\n  }\r\n}","return this.unsubAll;"],"parameters":[{"name":"newSink","type":"EventSink<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}},{"name":"guardedSink","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"guardedSink","statements":["return (event: Event<V>) => {\r\n  if (event.isEnd) {\r\n    this.unsubscribeInput(input);\r\n    return noMore;\r\n  } else if (this.sink) {\r\n    return this.sink(event);\r\n  } else {\r\n    return more;\r\n  }\r\n};"],"parameters":[{"name":"input","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"EventSink<V>","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}},{"name":"subscribeInput","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"subscribeInput","statements":["subscription.unsub = subscription.input.subscribeInternal(this.guardedSink(subscription.input));","return subscription.unsub;"],"parameters":[{"name":"subscription","type":"Subscription<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}},{"name":"unsubscribeInput","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"unsubscribeInput","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"iterable","initializer":"this.subscriptions","hasExclamationToken":false,"kind":40}]},"for (var i = 0, sub; i < iterable.length; i++) {\r\n  sub = iterable[i];\r\n  if (sub.input === input) {\r\n    if (typeof sub.unsub === \"function\") { \r\n      sub.unsub(); \r\n    }\r\n    this.subscriptions.splice(i, 1);\r\n    return;\r\n  }\r\n}"],"parameters":[{"name":"input","type":"Observable<any>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Bus","modulePath":"..\\src\\bus.ts"}}}]}},"usabilityResult":{"index":0}},"..\\src\\describe.ts":{"moduleComponents":{"Desc":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"deps","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"deps","statements":["if (!this.cachedDeps) {\r\n  this.cachedDeps = findDeps([this.context].concat(this.args));\r\n}","return this.cachedDeps;"],"parameters":[],"returnType":"Observable<any>[]","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Desc","modulePath":"..\\src\\describe.ts"}}},{"name":"toString","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toString","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"args","initializer":"_.map(_.toString, this.args)","hasExclamationToken":false,"kind":40}]},"return  _.toString(this.context) + \".\" + _.toString(this.method) + \"(\" + args + \")\";"],"parameters":[],"typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Desc","modulePath":"..\\src\\describe.ts"}}}]}},"usabilityResult":{"index":0}},"..\\src\\event.ts":{"moduleComponents":{"Event":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"filter","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"filter","statements":["return true"],"parameters":[{"name":"f","type":"(value: V) => boolean","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"boolean","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Event","modulePath":"..\\src\\event.ts"}}},{"name":"inspect","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"inspect","statements":["return this.toString()"],"parameters":[],"returnType":"string","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Event","modulePath":"..\\src\\event.ts"}}},{"name":"log","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"log","statements":["return this.toString()"],"parameters":[],"returnType":"any","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Event","modulePath":"..\\src\\event.ts"}}},{"name":"toNext","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toNext","statements":["return this"],"parameters":[],"returnType":"Event<V>","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Event","modulePath":"..\\src\\event.ts"}}}]},"Next":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"apply","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"apply","statements":["return new Next<V2>(value)"],"parameters":[{"name":"value","type":"V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Next<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Next","modulePath":"..\\src\\event.ts"}}}]},"Initial":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"apply","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"apply","statements":["return new Initial<V2>(value)"],"parameters":[{"name":"value","type":"V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Initial<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Initial","modulePath":"..\\src\\event.ts"}}},{"name":"toNext","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toNext","statements":["return new Next(this.value)"],"parameters":[],"returnType":"Next<V>","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Initial","modulePath":"..\\src\\event.ts"}}}]},"End":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"toString","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toString","statements":["return \"<end>\""],"parameters":[],"returnType":"string","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"End","modulePath":"..\\src\\event.ts"}}}]},"Error":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"toString","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toString","statements":["return \"<error> \" + _.toString(this.error)"],"parameters":[],"typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Error","modulePath":"..\\src\\event.ts"}}}]},"Value":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"fmap","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"fmap","statements":["return this.apply(f(this.value))"],"parameters":[{"name":"f","type":"(value: V) => V2","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Value<V2>","typeParameters":[{"name":"V2","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Value","modulePath":"..\\src\\event.ts"}}},{"name":"filter","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"filter","statements":["return f(this.value)"],"parameters":[{"name":"f","type":"(value: V)=>boolean","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"boolean","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Value","modulePath":"..\\src\\event.ts"}}},{"name":"toString","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"toString","statements":["return _.toString(this.value)"],"parameters":[],"returnType":"string","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Value","modulePath":"..\\src\\event.ts"}}},{"name":"log","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"log","statements":["return this.value;"],"parameters":[],"returnType":"any","typeParameters":[],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"Value","modulePath":"..\\src\\event.ts"}}}]},"hasValue":{"kind":13,"usabilityResult":{"wordCount":32,"index":0.64},"sources":{"name":"hasValue","statements":["return e.hasValue"],"parameters":[{"name":"e","type":"Event<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"e is Value<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nReturns true if the given event is a [Value](classes/value.html), i.e. a [Next](classes/next.html) or\r\nan [Initial](classes/error.html) value of an [Observable](classes/observable.html).","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"hasValue","modulePath":"..\\src\\event.ts"}},"isError":{"kind":13,"usabilityResult":{"wordCount":19,"index":0.38},"sources":{"name":"isError","statements":["return e.isError"],"parameters":[{"name":"e","type":"Event<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"e is Error","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nReturns true if the given event is an [Error](classes/error.html) event of an [Observable](classes/observable.html).","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"isError","modulePath":"..\\src\\event.ts"}},"isEnd":{"kind":13,"usabilityResult":{"wordCount":12,"index":0.24},"sources":{"name":"isEnd","statements":["return e.isEnd"],"parameters":[{"name":"e","type":"Event<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"e is End","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nReturns true if the given event is an [End](classes/end.html)","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"isEnd","modulePath":"..\\src\\event.ts"}},"isInitial":{"kind":13,"usabilityResult":{"wordCount":19,"index":0.38},"sources":{"name":"isInitial","statements":["return e && (e as any)._isInitial"],"parameters":[{"name":"e","type":"Event<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"e is Initial<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nReturns true if the given event is an [Initial](classes/initial.html) value of a [Property](classes/property.html).","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"isInitial","modulePath":"..\\src\\event.ts"}},"isEvent":{"kind":13,"usabilityResult":{"wordCount":12,"index":0.24},"sources":{"name":"isEvent","statements":["return e && e._isEvent"],"parameters":[{"name":"e","type":"any","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"e is Event<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nReturns true if the given object is an [Event](classes/event.html).","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"isEvent","modulePath":"..\\src\\event.ts"}},"isNext":{"kind":13,"usabilityResult":{"wordCount":12,"index":0.24},"sources":{"name":"isNext","statements":["return e.isNext"],"parameters":[{"name":"e","type":"Event<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"e is Next<V>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\nReturns true if the given event is a [Next](classes/next.html)","tags":[]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"isNext","modulePath":"..\\src\\event.ts"}}},"usabilityResult":{"index":0.17666666666666667}},"..\\src\\compositeunsubscribe.ts":{"moduleComponents":{"CompositeUnsubscribe":{"kind":2,"usabilityResult":{"wordCount":0,"index":0},"methods":[{"name":"add","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"add","statements":["if (!this.unsubscribed) {\r\n  var ended = false\r\n  var unsub: Unsub = nop\r\n  this.starting.push(subscription);\r\n  var unsubMe = () => {\r\n    if (this.unsubscribed) { return; }\r\n    ended = true;\r\n    this.remove(unsub);\r\n    _.remove(subscription, this.starting);\r\n  }\r\n  unsub = subscription(this.unsubscribe, unsubMe);\r\n  if (!(this.unsubscribed || ended)) {\r\n    this.subscriptions.push(unsub);\r\n  } else {\r\n    unsub();\r\n  }\r\n  _.remove(subscription, this.starting)\r\n}"],"parameters":[{"name":"subscription","type":"Subscription","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"void","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"CompositeUnsubscribe","modulePath":"..\\src\\compositeunsubscribe.ts"}}},{"name":"remove","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"remove","statements":["if (this.unsubscribed) { return; }","if ((_.remove(unsub, this.subscriptions)) !== undefined) { return unsub(); }"],"parameters":[{"name":"unsub","type":"Unsub","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"void","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"CompositeUnsubscribe","modulePath":"..\\src\\compositeunsubscribe.ts"}}},{"name":"unsubscribe","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"unsubscribe","statements":["if (this.unsubscribed) { return; }","this.unsubscribed = true;",{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"iterable","initializer":"this.subscriptions","hasExclamationToken":false,"kind":40}]},"for (var i = 0; i < iterable.length; i++) {\r\n  iterable[i]();\r\n}","this.subscriptions = [];","this.starting = []"],"parameters":[],"returnType":"void","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"CompositeUnsubscribe","modulePath":"..\\src\\compositeunsubscribe.ts"}}},{"name":"count","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"count","statements":["if (this.unsubscribed) { return 0; }","return this.subscriptions.length + this.starting.length;"],"parameters":[],"returnType":"number","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"CompositeUnsubscribe","modulePath":"..\\src\\compositeunsubscribe.ts"}}},{"name":"empty","usabilityResult":{"index":0,"wordCount":null},"sources":{"name":"empty","statements":["return this.count() === 0;"],"parameters":[],"returnType":"boolean","typeParameters":[],"docs":[],"isGenerator":false,"isAsync":false,"isStatic":false,"hasQuestionToken":false,"isAbstract":false,"decorators":[],"hasOverrideKeyword":false,"kind":26,"overloads":[],"declarationInfo":{"className":"CompositeUnsubscribe","modulePath":"..\\src\\compositeunsubscribe.ts"}}}]}},"usabilityResult":{"index":0}},"..\\src\\try.ts":{"moduleComponents":{"try":{"kind":13,"usabilityResult":{"wordCount":0,"index":0},"sources":{"name":"tryF","statements":["return function(value) {\r\ntry {\r\n  return once(f(value));\r\n} catch(e) {\r\n  return once(new Error(e));\r\n}\r\n};"],"parameters":[{"name":"f","type":"(value: In) => Out","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"(value: In) => EventStream<Out>","typeParameters":[{"name":"In","kind":39,"isConst":false,"variance":0},{"name":"Out","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isExported":true,"isDefaultExport":true,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"try","modulePath":"..\\src\\try.ts"}}},"usabilityResult":{"index":0}},"..\\src\\scheduler.ts":{"moduleComponents":{"getScheduler":{"kind":13,"usabilityResult":{"wordCount":0,"index":0},"sources":{"name":"getScheduler","statements":["return  GlobalScheduler.scheduler"],"parameters":[],"returnType":"Scheduler","typeParameters":[],"docs":[],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"getScheduler","modulePath":"..\\src\\scheduler.ts"}},"setScheduler":{"kind":13,"usabilityResult":{"wordCount":0,"index":0},"sources":{"name":"setScheduler","statements":["GlobalScheduler.scheduler = newScheduler"],"parameters":[{"name":"newScheduler","type":"Scheduler","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"typeParameters":[],"docs":[],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"setScheduler","modulePath":"..\\src\\scheduler.ts"}}},"usabilityResult":{"index":0}},"..\\src\\update.ts":{"moduleComponents":{"update":{"kind":13,"usabilityResult":{"wordCount":189,"index":1},"sources":{"name":"update","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"let","declarations":[{"name":"rawPatterns","initializer":"extractRawPatterns(<any>patterns)","hasExclamationToken":false,"kind":40}]},"for (var i = 0; i < rawPatterns.length; i++) {\r\nlet pattern = rawPatterns[i];\r\npattern[1] = lateBindFirst(pattern[1])\r\n}","return when(...rawPatterns).scan(initial, (function (x, f: Function) {\r\nreturn f(x)\r\n})).withDesc(new Desc(\"Bacon\", \"update\", [initial, ...patterns]))"],"parameters":[{"name":"initial","type":"Out","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"patterns","type":"UpdatePattern<Out>[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"Property<Out>","typeParameters":[{"name":"Out","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Creates a Property from an initial value and updates the value based on multiple inputs.\r\n The inputs are defined similarly to [`Bacon.when`](#bacon-when), like this:\r\n\r\n ```js\r\n var result = Bacon.update(\r\n initial,\r\n [x,y,z, (previous,x,y,z) => { ... }],\r\n [x,y,   (previous,x,y) => { ... }])\r\n ```\r\n\r\n As input, each function above will get the previous value of the `result` Property, along with values from the listed Observables.\r\n The value returned by the function will be used as the next value of `result`.\r\n\r\n Just like in [`Bacon.when`](#when), only EventStreams will trigger an update, while Properties will be just sampled.\r\n So, if you list a single EventStream and several Properties, the value will be updated only when an event occurs in the EventStream.\r\n\r\n Here's a simple gaming example:\r\n\r\n ```js\r\n let scoreMultiplier = Bacon.constant(1)\r\n let hitUfo = Bacon.interval(1000)\r\n let hitMotherShip = Bacon.later(10000)\r\n let score = Bacon.update(\r\n 0,\r\n [hitUfo, scoreMultiplier, (score, _, multiplier) => score + 100 * multiplier ],\r\n [hitMotherShip, (score, _) => score + 2000 ]\r\n )\r\n ```\r\n\r\n In the example, the `score` property is updated when either `hitUfo` or `hitMotherShip` occur. The `scoreMultiplier` Property is sampled to take multiplier into account when `hitUfo` occurs.","tags":[{"kind":25,"tagName":"param","text":"initial"},{"kind":25,"tagName":"param","text":"{UpdatePattern<Out>} patterns"},{"kind":25,"tagName":"returns","text":"{Property<Out>}"}]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"update","modulePath":"..\\src\\update.ts"}}},"usabilityResult":{"index":1}},"..\\src\\combine.ts":{"moduleComponents":{"combineAsArray":{"kind":13,"usabilityResult":{"wordCount":55,"index":1},"sources":{"name":"combineAsArray","statements":["streams = argumentsToObservables(streams)","if (streams.length) {\r\nvar sources: Source<V, V>[] = [];\r\nfor (var i = 0; i < streams.length; i++) {\r\n  let stream: Observable<V> = <any>(isObservable(streams[i])\r\n    ? streams[i]\r\n    : constant(streams[i]))\r\n  sources.push(wrap(stream));\r\n}\r\nreturn whenP<V[]>([sources, (...xs: V[]) => xs]).withDesc(new Desc(\"Bacon\", \"combineAsArray\", streams));\r\n} else {\r\nreturn constant<V[]>([]);\r\n}"],"parameters":[{"name":"streams","type":"(Observable<V> | Observable<V>[])[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"Property<V[]>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n Combines Properties, EventStreams and constant values so that the result Property will have an array of the latest\r\n values from all sources as its value. The inputs may contain both Properties and EventStreams.\r\n\r\n\r\n ```js\r\n property = Bacon.constant(1)\r\n stream = Bacon.once(2)\r\n constant = 3\r\n Bacon.combineAsArray(property, stream, constant)\r\n # produces the value [1,2,3]\r\n ```","tags":[{"kind":25,"tagName":"param","text":"streams streams and properties to combine"}]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"combineAsArray","modulePath":"..\\src\\combine.ts"}},"combineWith":{"kind":13,"usabilityResult":{"wordCount":43,"index":0.86},"sources":{"name":"combineWith","statements":[{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"[streams, f]","initializer":"argumentsToObservablesAndFunction<Out>(arguments)","hasExclamationToken":false,"kind":40}]},{"isExported":false,"isDefaultExport":false,"hasDeclareKeyword":false,"docs":[],"kind":41,"declarationKind":"var","declarations":[{"name":"desc","initializer":"new Desc(\"Bacon\", \"combineWith\", [f, ...streams])","hasExclamationToken":false,"kind":40}]},"return combineAsArray(streams).map(function (values) {\r\nreturn f(...values);\r\n}).withDesc(desc);"],"parameters":[{"name":"args","type":"any[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":true}],"returnType":"Property<Out>","typeParameters":[{"name":"Out","kind":39,"isConst":false,"variance":0}],"docs":[],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"\r\n  Combines given *n* Properties and\r\n  EventStreams using the given n-ary function `f(v1, v2 ...)`.\r\n\r\n  To calculate the current sum of three numeric Properties, you can do\r\n\r\n```js\r\nfunction sum3(x,y,z) { return x + y + z }\r\nBacon.combineWith(sum3, p1, p2, p3)\r\n```","tags":[]}],"hasDeclareKeyword":false,"parameters":[{"name":"fn","type":"Function0<R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"fn","type":"Function1<V, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"fn","type":"Function2<V, V2, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"V3","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"c","type":"Observable<V3>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"fn","type":"Function3<V, V2, V3, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"V3","kind":39,"isConst":false,"variance":0},{"name":"V4","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"c","type":"Observable<V3>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"d","type":"Observable<V4>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"fn","type":"Function4<V, V2, V3, V4, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"V3","kind":39,"isConst":false,"variance":0},{"name":"V4","kind":39,"isConst":false,"variance":0},{"name":"V5","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"c","type":"Observable<V3>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"d","type":"Observable<V4>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"e","type":"Observable<V5>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"fn","type":"Function5<V, V2, V3, V4, V5, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"V3","kind":39,"isConst":false,"variance":0},{"name":"V4","kind":39,"isConst":false,"variance":0},{"name":"V5","kind":39,"isConst":false,"variance":0},{"name":"V6","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"c","type":"Observable<V3>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"d","type":"Observable<V4>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"e","type":"Observable<V5>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Observable<V6>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"fn","type":"Function6<V, V2, V3, V4, V5, V6, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"observables","type":"Observable<any>[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"fn","type":"Function","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"fn","type":"Function1<V, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"fn","type":"Function2<V, V2, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"V3","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"fn","type":"Function3<V, V2, V3, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"c","type":"Observable<V3>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"V3","kind":39,"isConst":false,"variance":0},{"name":"V4","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"fn","type":"Function4<V, V2, V3, V4, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"c","type":"Observable<V3>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"d","type":"Observable<V4>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"V3","kind":39,"isConst":false,"variance":0},{"name":"V4","kind":39,"isConst":false,"variance":0},{"name":"V5","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"fn","type":"Function5<V, V2, V3, V4, V5, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"c","type":"Observable<V3>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"d","type":"Observable<V4>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"e","type":"Observable<V5>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"V3","kind":39,"isConst":false,"variance":0},{"name":"V4","kind":39,"isConst":false,"variance":0},{"name":"V5","kind":39,"isConst":false,"variance":0},{"name":"V6","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"fn","type":"Function6<V, V2, V3, V4, V5, V6, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"a","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"b","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"c","type":"Observable<V3>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"d","type":"Observable<V4>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"e","type":"Observable<V5>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Observable<V6>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"},{"isExported":true,"isDefaultExport":false,"typeParameters":[{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[],"hasDeclareKeyword":false,"parameters":[{"name":"fn","type":"Function","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"observables","type":"Observable<any>[]","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","isGenerator":false,"isAsync":false,"kind":14,"functionName":"combineWith","modulePath":"..\\src\\combine.ts"}]}},"combineTwo":{"kind":13,"usabilityResult":{"wordCount":0,"index":0},"sources":{"name":"combineTwo","statements":["return whenP([[wrap(left), wrap(right)], f]).withDesc(new Desc(left, \"combine\", [right, f]));"],"parameters":[{"name":"left","type":"Observable<V>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"right","type":"Observable<V2>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false},{"name":"f","type":"Function2<V, V2, R>","isReadonly":false,"decorators":[],"hasQuestionToken":false,"hasOverrideKeyword":false,"kind":30,"isRestParameter":false}],"returnType":"Property<R>","typeParameters":[{"name":"V","kind":39,"isConst":false,"variance":0},{"name":"V2","kind":39,"isConst":false,"variance":0},{"name":"R","kind":39,"isConst":false,"variance":0}],"docs":[{"kind":24,"description":"","tags":[{"kind":25,"tagName":"hidden"}]}],"isExported":true,"isDefaultExport":false,"hasDeclareKeyword":false,"isGenerator":false,"isAsync":false,"kind":13,"overloads":[],"functionName":"combineTwo","modulePath":"..\\src\\combine.ts"}}},"usabilityResult":{"index":0.62}}}}